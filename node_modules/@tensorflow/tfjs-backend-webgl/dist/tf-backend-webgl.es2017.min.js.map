{"version":3,"file":"tf-backend-webgl.es2017.min.js","sources":["../src/canvas_util.ts","../src/tex_util.ts","../src/webgl_util.ts","../src/flags_webgl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js","../src/kernel_utils/shared.ts","../src/addn_gpu.ts","../src/addn_packed_gpu.ts","../src/argminmax_gpu.ts","../src/packing_util.ts","../src/glsl_version.ts","../src/shader_compiler_util.ts","../src/shader_compiler.ts","../src/argminmax_packed_gpu.ts","../src/avg_pool_backprop_gpu.ts","../src/binaryop_gpu.ts","../src/binaryop_packed_gpu.ts","../src/clip_gpu.ts","../src/clip_packed_gpu.ts","../src/complex_abs_gpu.ts","../src/conv_backprop_gpu.ts","../src/conv_backprop_gpu_depthwise.ts","../src/conv_gpu.ts","../src/conv_gpu_depthwise.ts","../src/conv_packed_gpu_depthwise.ts","../src/crop_and_resize_gpu.ts","../src/cumsum_gpu.ts","../src/decode_matrix_gpu.ts","../src/decode_matrix_packed_gpu.ts","../src/depth_to_space_gpu.ts","../src/diag_gpu.ts","../src/encode_float_gpu.ts","../src/encode_float_packed_gpu.ts","../src/encode_matrix_gpu.ts","../src/encode_matrix_packed_gpu.ts","../src/fill_gpu.ts","../src/gather_gpu.ts","../src/gather_nd_gpu.ts","../src/gpgpu_util.ts","../src/gpgpu_context.ts","../src/gpgpu_math.ts","../src/im2col_packed_gpu.ts","../src/lrn_gpu.ts","../src/lrn_grad_gpu.ts","../src/lrn_packed_gpu.ts","../src/max_pool_backprop_gpu.ts","../src/mulmat_packed_gpu.ts","../src/multinomial_gpu.ts","../src/onehot_gpu.ts","../src/pack_gpu.ts","../src/pad_gpu.ts","../src/pad_packed_gpu.ts","../src/pool_gpu.ts","../src/reduce_gpu.ts","../src/reshape_packed_gpu.ts","../src/resize_bilinear_backprop_gpu.ts","../src/resize_bilinear_gpu.ts","../src/resize_bilinear_packed_gpu.ts","../src/resize_nearest_neighbor_backprop_gpu.ts","../src/resize_nearest_neighbor_gpu.ts","../src/reverse_gpu.ts","../src/reverse_packed_gpu.ts","../src/scatter_gpu.ts","../src/segment_gpu.ts","../src/select_gpu.ts","../src/slice_gpu.ts","../src/slice_packed_gpu.ts","../src/strided_slice_gpu.ts","../src/texture_manager.ts","../src/tile_gpu.ts","../src/unaryop_gpu.ts","../src/unaryop_packed_gpu.ts","../src/unpack_gpu.ts","../src/backend_webgl.ts","../src/webgl.ts","../src/base.ts","../src/kernels/Identity.ts","../src/kernels/Complex.ts","../src/kernel_utils/kernel_funcs_utils.ts","../src/kernels/Add.ts","../src/kernels/Atan2.ts","../src/kernels/AvgPool.ts","../src/kernels/AvgPoolBackprop.ts","../src/batchnorm_gpu.ts","../src/batchnorm_packed_gpu.ts","../src/kernels/BatchNorm.ts","../src/kernels/NotEqual.ts","../src/kernels/Real.ts","../src/kernels/Cast.ts","../src/kernel_utils/int.ts","../src/concat_gpu.ts","../src/concat_packed_gpu.ts","../src/kernels/Imag.ts","../src/kernels/Reshape.ts","../src/kernel_utils/reshape.ts","../src/kernels/Concat.ts","../src/kernels/Concat_impl.ts","../src/kernels/Cos.ts","../src/kernels/Div.ts","../src/fft_gpu.ts","../src/kernels/FFT_impl.ts","../src/kernels/FFT.ts","../src/flip_left_right_gpu.ts","../src/kernels/FlipLeftRight.ts","../src/kernels/FromPixels_utils/from_pixels_gpu.ts","../src/kernels/FromPixels_utils/from_pixels_packed_gpu.ts","../src/kernels/FromPixels.ts","../src/kernels/IFFT.ts","../src/mean_gpu.ts","../src/kernel_utils/reduce.ts","../src/transpose_gpu.ts","../src/transpose_packed_gpu.ts","../src/kernels/Transpose_impl.ts","../src/kernels/Max.ts","../src/kernels/Max_impl.ts","../src/kernels/MaxPool.ts","../src/kernels/MaxPoolBackprop.ts","../src/kernels/MaxPoolWithArgmax.ts","../src/kernels/MaxPoolWithArgmax_impl.ts","../src/kernels/Mean.ts","../src/kernels/Mean_impl.ts","../src/mirror_pad_gpu.ts","../src/mirror_pad_packed_gpu.ts","../src/kernels/MirrorPad.ts","../src/binaryop_complex_gpu.ts","../src/kernels/Multiply.ts","../src/kernels/NonMaxSuppressionV3.ts","../src/kernels/NonMaxSuppressionV4.ts","../src/kernels/NonMaxSuppressionV5.ts","../src/rotate_gpu.ts","../src/kernels/RotateWithOffset.ts","../src/kernels/Sin.ts","../src/kernels/Square.ts","../src/kernels/SquaredDifference.ts","../src/kernels/Sub.ts","../src/kernels/Tan.ts","../src/kernels/Unique.ts","../src/register_all_kernels.ts","../src/kernels/Transpose.ts","../src/version.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nconst contexts: {[key: string]: WebGLRenderingContext} = {};\n\nconst WEBGL_ATTRIBUTES: WebGLContextAttributes = {\n  alpha: false,\n  antialias: false,\n  premultipliedAlpha: false,\n  preserveDrawingBuffer: false,\n  depth: false,\n  stencil: false,\n  failIfMajorPerformanceCaveat: true\n};\n\nexport function clearWebGLContext(webGLVersion: number) {\n  delete contexts[webGLVersion];\n}\n\nexport function setWebGLContext(\n    webGLVersion: number, gl: WebGLRenderingContext) {\n  contexts[webGLVersion] = gl;\n}\n\nexport function getWebGLContext(webGLVersion: number): WebGLRenderingContext {\n  if (!(webGLVersion in contexts)) {\n    const newCtx = getWebGLRenderingContext(webGLVersion);\n    if (newCtx !== null) {\n      contexts[webGLVersion] = newCtx;\n    } else {\n      console.log('Could not get context for WebGL version', webGLVersion);\n      return null;\n    }\n  }\n  const gl = contexts[webGLVersion];\n  if (gl.isContextLost()) {\n    delete contexts[webGLVersion];\n    return getWebGLContext(webGLVersion);\n  }\n\n  gl.disable(gl.DEPTH_TEST);\n  gl.disable(gl.STENCIL_TEST);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.DITHER);\n  gl.disable(gl.POLYGON_OFFSET_FILL);\n  gl.disable(gl.SAMPLE_COVERAGE);\n  gl.enable(gl.SCISSOR_TEST);\n  gl.enable(gl.CULL_FACE);\n  gl.cullFace(gl.BACK);\n\n  return contexts[webGLVersion];\n}\n\nfunction createCanvas(webGLVersion: number) {\n  if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {\n    return new OffscreenCanvas(300, 150);\n  } else if (typeof document !== 'undefined') {\n    return document.createElement('canvas');\n  } else {\n    throw new Error('Cannot create a canvas in this context');\n  }\n}\n\nfunction getWebGLRenderingContext(webGLVersion: number): WebGLRenderingContext {\n  if (webGLVersion !== 1 && webGLVersion !== 2) {\n    throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n  }\n  const canvas = createCanvas(webGLVersion);\n\n  canvas.addEventListener('webglcontextlost', (ev: Event) => {\n    ev.preventDefault();\n    delete contexts[webGLVersion];\n  }, false);\n  if (webGLVersion === 1) {\n    return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||\n            canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES)) as\n        WebGLRenderingContext;\n  }\n  return canvas.getContext('webgl2', WEBGL_ATTRIBUTES) as WebGLRenderingContext;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataId, DataType, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nexport enum PackingScheme {\n  /**\n   * All values in a single texel are densely packed without any constraints.\n   *\n   * This is how the shader encodes a tensor with shape = [2, 3, 4]\n   * (indices are [batch, row, col]).\n   *\n   * 000|001   010|011   020|021\n   * -------   -------   -------\n   * 002|003   012|013   022|023\n   *\n   * 100|101   110|111   120|121\n   * -------   -------   -------\n   * 102|103   112|113   122|123\n   *\n   */\n  DENSE,\n\n  /**\n   * Single texels contain only values from the same batch, and from adjacent\n   * rows and columns.\n   *\n   * This is how the shader encodes a tensor with shape = [2, 3, 5]\n   * (indices are [batch, row, col]).\n   *\n   * 000|001   002|003   004|xxx   020|021   022|023   024|xxx\n   * -------   -------   -------   -------   -------   -------\n   * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n   *\n   * 100|101   102|103   104|xxx   120|121   122|123   124|xxx\n   * -------   -------   -------   -------   -------   -------\n   * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n   *\n   */\n  SHARED_BATCH\n}\n\nexport enum TextureUsage {\n  RENDER,\n  UPLOAD,\n  PIXELS,\n  DOWNLOAD\n}\n\nexport enum PhysicalTextureType {\n  UNPACKED_FLOAT16,\n  UNPACKED_FLOAT32,\n  PACKED_4X1_UNSIGNED_BYTE,\n  PACKED_2X2_FLOAT32,\n  PACKED_2X2_FLOAT16\n}\n\nexport interface TextureData {\n  // Required.\n  shape: number[];\n  dtype: DataType;\n\n  // Optional.\n  values?: backend_util.BackendValues;\n  texture?: WebGLTexture;\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensorInfos, with a parent joining the two with the\n  // complexTensors field. When this is defined, texture will be null.\n  complexTensorInfos?: {real: TensorInfo, imag: TensorInfo};\n  /** [rows, columns] shape of the texture. */\n  texShape?: [number, number];\n  usage?: TextureUsage;\n  isPacked?: boolean;\n\n  refCount: number;\n  // The number of complex tensors that point to this TextureData. Unlike\n  // `refCount` above, `complexParentRefCount` must be at 0 before a TextureData\n  // can be disposed. There is no mechanism for bypassing this condition in the\n  // WebGL backend, whereas calling `disposeData` will dispose the TextureData\n  // even if its `refCount` is greater than 0.\n  complexParentRefCount: number;\n\n  // Available when the tensor has been sliced.\n  slice?: {\n    // Offset in the 'flat index' space.\n    flatOffset: number;\n    // Used for counting how many sliced tensors point to the same texture.\n    origDataId: DataId;\n  };\n}\n\nexport function getUnpackedMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [columns, rows];\n}\n\nexport function getUnpackedArraySizeFromMatrixSize(\n    matrixSize: number, channelsPerTexture: number): number {\n  return matrixSize * channelsPerTexture;\n}\n\nexport function getColorMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [columns * 4, rows];\n}\n\n/**\n * Get shape for densely packed RGBA texture.\n */\nexport function getDenseTexShape(shape: number[]): [number, number] {\n  const size = util.sizeFromShape(shape);\n  const texelsNeeded = Math.ceil(size / 4);\n  return util.sizeToSquarishShape(texelsNeeded);\n}\n\nexport function getMatrixSizeFromUnpackedArraySize(\n    unpackedSize: number, channelsPerTexture: number): number {\n  if (unpackedSize % channelsPerTexture !== 0) {\n    throw new Error(\n        `unpackedSize (${unpackedSize}) must be a multiple of ` +\n        `${channelsPerTexture}`);\n  }\n  return unpackedSize / channelsPerTexture;\n}\n\nexport function decodeMatrixFromUnpackedColorRGBAArray(\n    unpackedArray: Float32Array, matrix: Float32Array, channels: number) {\n  const requiredSize = unpackedArray.length * channels / 4;\n  if (matrix.length < requiredSize) {\n    throw new Error(\n        `matrix length (${matrix.length}) must be >= ${requiredSize}`);\n  }\n  let dst = 0;\n  for (let src = 0; src < unpackedArray.length; src += 4) {\n    for (let c = 0; c < channels; c++) {\n      matrix[dst++] = unpackedArray[src + c];\n    }\n  }\n}\n\nexport function getPackedMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [\n    Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))\n  ];\n}\n\nexport function getPackedRGBAArraySizeFromMatrixShape(\n    rows: number, columns: number): number {\n  const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return w * h * 4;\n}\n\nexport interface TextureConfig {\n  internalFormatFloat: number;\n  textureFormatFloat: number;\n  internalFormatPackedHalfFloat: number;\n  internalFormatHalfFloat: number;\n  internalFormatPackedFloat: number;\n\n  // The format to use during a gl.readPixels call.\n  downloadTextureFormat: number;\n  // How many channels need to be unpacked after a gl.readPixels call.\n  downloadUnpackNumChannels: number;\n\n  defaultNumChannels: number;\n  textureTypeHalfFloat: number;\n  textureTypeFloat: number;\n}\n\nexport function getTextureConfig(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension?: any): TextureConfig {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n\n  let internalFormatFloat: number;\n  let internalFormatHalfFloat: number;\n  let internalFormatPackedHalfFloat: number;\n  let internalFormatPackedFloat: number;\n  let textureFormatFloat: number;\n\n  let downloadTextureFormat: number;\n  let downloadUnpackNumChannels: number;\n\n  let defaultNumChannels: number;\n  let textureTypeHalfFloat: number;\n  let textureTypeFloat: number;\n\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    internalFormatFloat = glany.R32F;\n    internalFormatHalfFloat = glany.R16F;\n    internalFormatPackedHalfFloat = glany.RGBA16F;\n    internalFormatPackedFloat = glany.RGBA32F;\n    textureFormatFloat = glany.RED;\n    downloadUnpackNumChannels = 4;\n    defaultNumChannels = 1;\n    textureTypeHalfFloat = glany.HALF_FLOAT;\n    textureTypeFloat = glany.FLOAT;\n  } else {\n    internalFormatFloat = gl.RGBA;\n    internalFormatHalfFloat = gl.RGBA;\n    internalFormatPackedHalfFloat = gl.RGBA;\n    internalFormatPackedFloat = glany.RGBA;\n    textureFormatFloat = gl.RGBA;\n    downloadUnpackNumChannels = 4;\n    defaultNumChannels = 4;\n    textureTypeHalfFloat = textureHalfFloatExtension != null ?\n        textureHalfFloatExtension.HALF_FLOAT_OES :\n        null;\n    textureTypeFloat = gl.FLOAT;\n  }\n  downloadTextureFormat = gl.RGBA;\n\n  return {\n    internalFormatFloat,\n    internalFormatHalfFloat,\n    internalFormatPackedHalfFloat,\n    internalFormatPackedFloat,\n    textureFormatFloat,\n    downloadTextureFormat,\n    downloadUnpackNumChannels,\n    defaultNumChannels,\n    textureTypeHalfFloat,\n    textureTypeFloat\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext} from './canvas_util';\nimport {getTextureConfig} from './tex_util';\n\nexport function callAndCheck<T>(gl: WebGLRenderingContext, func: () => T): T {\n  const returnValue = func();\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\n\nfunction checkWebGLError(gl: WebGLRenderingContext) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\n\nexport function canBeRepresented(num: number): boolean {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n      (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n    return true;\n  }\n  return false;\n}\n\nexport function getWebGLErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\n\nexport function getExtensionOrThrow(\n    gl: WebGLRenderingContext, extensionName: string): {} {\n  return throwIfNull<{}>(\n      gl, () => gl.getExtension(extensionName),\n      'Extension \"' + extensionName + '\" not supported on this browser.');\n}\n\nexport function createVertexShader(\n    gl: WebGLRenderingContext, vertexShaderSource: string): WebGLShader {\n  const vertexShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.VERTEX_SHADER),\n      'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\n\nexport function createFragmentShader(\n    gl: WebGLRenderingContext, fragmentShaderSource: string): WebGLShader {\n  const fragmentShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.FRAGMENT_SHADER),\n      'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(\n        fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\n\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(\n    shaderSource: string, shaderInfoLog: string) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map(\n      (line, lineNumber) =>\n          util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\n      `%c ${util.rightPad(errorLine[0], maxLineLength)}`,\n      'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl: WebGLRenderingContext): WebGLProgram {\n  return throwIfNull<WebGLProgram>(\n      gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\n\nexport function linkProgram(gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\n\nexport function validateProgram(\n    gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\n\nexport function createStaticVertexBuffer(\n    gl: WebGLRenderingContext, data: Float32Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function createStaticIndexBuffer(\n    gl: WebGLRenderingContext, data: Uint16Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function getNumChannels(): number {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\n\nexport function createTexture(gl: WebGLRenderingContext): WebGLTexture {\n  return throwIfNull<WebGLTexture>(\n      gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\n\nexport function validateTextureSize(width: number, height: number) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if ((width <= 0) || (height <= 0)) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if ((width > maxTextureSize) || (height > maxTextureSize)) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error(\n        'Requested texture size ' + requested +\n        ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\n\nexport function createFramebuffer(gl: WebGLRenderingContext): WebGLFramebuffer {\n  return throwIfNull<WebGLFramebuffer>(\n      gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\n\nexport function bindVertexBufferToProgramAttribute(\n    gl: WebGLRenderingContext, program: WebGLProgram, attribute: string,\n    buffer: WebGLBuffer, arrayEntriesPerItem: number, itemStrideInBytes: number,\n    itemOffsetInBytes: number): boolean {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl,\n      () => gl.vertexAttribPointer(\n          loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes,\n          itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\n\nexport function bindTextureUnit(\n    gl: WebGLRenderingContext, texture: WebGLTexture, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\n\nexport function unbindTextureUnit(\n    gl: WebGLRenderingContext, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function getProgramUniformLocationOrThrow(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return throwIfNull<WebGLUniformLocation>(\n      gl, () => gl.getUniformLocation(program, uniformName),\n      'uniform \"' + uniformName + '\" not present in program.');\n}\n\nexport function getProgramUniformLocation(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return gl.getUniformLocation(program, uniformName);\n}\n\nexport function bindTextureToProgramUniformSampler(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    uniformSamplerLocation: WebGLUniformLocation, textureUnit: number) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\n\nexport function bindCanvasToFramebuffer(gl: WebGLRenderingContext) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\n\nexport function bindColorTextureToFramebuffer(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\n\nexport function unbindColorTextureFromFramebuffer(\n    gl: WebGLRenderingContext, framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\n\nexport function validateFramebuffer(gl: WebGLRenderingContext) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error(\n        'Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\n\nexport function getFramebufferErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull<T>(\n    gl: WebGLRenderingContext, returnTOrNull: () => T | null,\n    failureMessage: string): T {\n  const tOrNull: T|null = callAndCheck(gl, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl: WebGLRenderingContext, textureUnit: number) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [\n    shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n  ];\n}\n\nexport function getShapeAs3D(shape: number[]): [number, number, number] {\n  let shapeAs3D: [number, number, number] = [1, 1, 1];\n  const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n  if (!isScalar) {\n    shapeAs3D =\n        [getBatchDim(shape), ...getRowsCols(shape)] as [number, number, number];\n  }\n  return shapeAs3D;\n}\n\nexport function getTextureShapeFromLogicalShape(\n    logShape: number[], isPacked = false): [number, number] {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map(\n        (d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (\n      logShape.length === 2 && logShape[0] <= maxTexSize &&\n      logShape[1] <= maxTexSize) {\n    return logShape as [number, number];\n  } else if (\n      logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n      logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (\n      logShape.length === 3 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n      logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (\n      logShape.length === 4 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n\n      const batchDim = getBatchDim(logShape);\n      let rows = 2, cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(d => d * 2) as [number, number];\n    }\n    return util.sizeToSquarishShape(size);\n  }\n}\n\nfunction isEven(n: number): boolean {\n  return n % 2 === 0;\n}\n\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1: number[], shape2: number[]): boolean {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {  // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n      shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {  // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) &&\n        (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE: number;\nlet MAX_TEXTURES_IN_SHADER: number;\n\nexport function getWebGLMaxTextureSize(webGLVersion: number): number {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\n\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\n\nexport function getMaxTexturesInShader(webGLVersion: number): number {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\n\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion: number):\n    number {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion: number;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n      webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\n\nexport function hasExtension(gl: WebGLRenderingContext, extensionName: string) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\n\nexport function isWebGLVersionEnabled(webGLVersion: 1|2) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n  return false;\n}\n\nexport function isCapableOfRenderingToFloatTexture(webGLVersion: number):\n    boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion: number): boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension =\n          gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(\n          gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl: WebGLRenderingContext):\n    boolean {\n  const texConfig = getTextureConfig(gl);\n\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension: any): boolean {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion: number) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n\n  // tslint:disable-next-line:no-any\n  const isEnabled = (gl as any).fenceSync != null;\n  return isEnabled;\n}\n\nexport function assertNotComplex(\n    tensor: TensorInfo|TensorInfo[], opName: string): void {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(\n          t.dtype !== 'complex64',\n          () => `${opName} does not support complex64 tensors ` +\n              'in the WebGL backend.');\n    }\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {device_util, env} from '@tensorflow/tfjs-core';\n\nimport {getMaxTexturesInShader, getWebGLDisjointQueryTimerVersion, getWebGLMaxTextureSize, isCapableOfRenderingToFloatTexture, isDownloadFloatTextureEnabled, isWebGLFenceEnabled, isWebGLVersionEnabled} from './webgl_util';\n\nconst ENV = env();\n\n/**\n * This file contains WebGL-specific flag registrations.\n */\n\n/**\n * True if WebGL is supported.\n */\nENV.registerFlag('HAS_WEBGL', () => ENV.getNumber('WEBGL_VERSION') > 0);\n\n/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */\nENV.registerFlag('WEBGL_VERSION', () => {\n  if (isWebGLVersionEnabled(2)) {\n    return 2;\n  } else if (isWebGLVersionEnabled(1)) {\n    return 1;\n  }\n  return 0;\n});\n\n/** Whether to check for numerical representation problems. */\nENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', () => false);\n\nENV.registerFlag(\n    'WEBGL_BUFFER_SUPPORTED', () => ENV.get('WEBGL_VERSION') === 2);\n\n/** Whether the WebGL backend will sometimes forward ops to the CPU. */\nENV.registerFlag('WEBGL_CPU_FORWARD', () => true);\n\n/** Whether the WebGL backend will always use f16 textures for rendering. */\nENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', () => false);\n\n/** Whether to turn all packing related flags on. */\nENV.registerFlag('WEBGL_PACK', () => ENV.getBool('HAS_WEBGL'));\n\n/** Whether we will pack the batchnormalization op. */\nENV.registerFlag('WEBGL_PACK_NORMALIZATION', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack the clip op. */\nENV.registerFlag('WEBGL_PACK_CLIP', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack the depthwise conv op. */\n// TODO: https://github.com/tensorflow/tfjs/issues/1679\nENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', () => false);\n\n/** Whether we will pack binary ops. */\nENV.registerFlag(\n    'WEBGL_PACK_BINARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack unary ops. */\nENV.registerFlag(\n    'WEBGL_PACK_UNARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack array ops. */\nENV.registerFlag(\n    'WEBGL_PACK_ARRAY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack image ops. */\nENV.registerFlag(\n    'WEBGL_PACK_IMAGE_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack reduce ops. */\nENV.registerFlag('WEBGL_PACK_REDUCE', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether packed WebGL kernels lazily unpack their outputs. */\nENV.registerFlag('WEBGL_LAZILY_UNPACK', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will use the im2col algorithm to speed up convolutions. */\nENV.registerFlag('WEBGL_CONV_IM2COL', () => ENV.getBool('WEBGL_PACK'));\n\n/** The maximum texture dimension. */\nENV.registerFlag(\n    'WEBGL_MAX_TEXTURE_SIZE',\n    () => getWebGLMaxTextureSize(ENV.getNumber('WEBGL_VERSION')));\n\n/** The maximum texture dimension. */\nENV.registerFlag(\n    'WEBGL_MAX_TEXTURES_IN_SHADER',\n    () => getMaxTexturesInShader(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * The disjoint_query_timer extension version.\n * 0: disabled, 1: EXT_disjoint_timer_query, 2:\n * EXT_disjoint_timer_query_webgl2.\n * In Firefox with WebGL 2.0,\n * EXT_disjoint_timer_query_webgl2 is not available, so we must use the\n * WebGL 1.0 extension.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', () => {\n  const webGLVersion = ENV.getNumber('WEBGL_VERSION');\n\n  if (webGLVersion === 0) {\n    return 0;\n  }\n  return getWebGLDisjointQueryTimerVersion(webGLVersion);\n});\n\n/**\n * Whether the timer object from the disjoint_query_timer extension gives\n * timing information that is reliable.\n */\nENV.registerFlag(\n    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE',\n    () => ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&\n        !device_util.isMobile());\n\n/**\n * Whether the device is physically capable of rendering to float32 textures.\n */\nENV.registerFlag(\n    'WEBGL_RENDER_FLOAT32_CAPABLE',\n    () => isCapableOfRenderingToFloatTexture(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * Whether rendering to float32 textures is enabled. If disabled, renders to\n * float16 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', () => {\n  return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?\n      false :\n      ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');\n});\n\n/**\n * Whether downloading float textures is enabled (16 or 32 bit). If disabled,\n * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.\n */\nENV.registerFlag(\n    'WEBGL_DOWNLOAD_FLOAT_ENABLED',\n    () => isDownloadFloatTextureEnabled(ENV.getNumber('WEBGL_VERSION')));\n\n/** Whether the fence API is available. */\nENV.registerFlag(\n    'WEBGL_FENCE_API_ENABLED',\n    () => isWebGLFenceEnabled(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * Tensors with size <= than this will be uploaded as uniforms, not textures.\n */\nENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', () => {\n  // Use uniform uploads only when 32bit floats are supported. In\n  // 16bit\n  // environments there are problems with comparing a 16bit texture value\n  // with a 32bit uniform value.\n  const useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');\n  return useUniforms ? 4 : 0;\n});\n\n/**\n * If the total number of bytes allocated on the GPU is greater than this\n * number, we will aggressively delete textures upon disposal with\n * gl.deleteMatrixTexture, rather than making them available for reuse.\n *\n * Default value -1 indicates that we will never aggressively delete textures.\n */\nENV.registerFlag(\n    'WEBGL_DELETE_TEXTURE_THRESHOLD',\n    () => {\n      return -1;\n    },\n    threshold => {\n      if (threshold < 0 && threshold !== -1) {\n        throw new Error(\n            `WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` +\n            `delete) or at least 0, but got ${threshold}.`);\n      }\n    });\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nexport function createSimpleBinaryKernelImpl(op) {\n    return (aShape, bShape, aVals, bVals, dtype) => {\n        const newShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const resultRank = newShape.length;\n        const resultStrides = util.computeStrides(newShape);\n        const resultSize = util.sizeFromShape(newShape);\n        const result = util.getTypedArrayFromDType(dtype, resultSize);\n        const aRank = aShape.length;\n        const bRank = bShape.length;\n        const aStrides = util.computeStrides(aShape);\n        const bStrides = util.computeStrides(bShape);\n        const aBroadcastDims = backend_util.getBroadcastDims(aShape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(bShape, newShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < result.length; ++i) {\n                result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            for (let i = 0; i < result.length; ++i) {\n                const loc = util.indexToLoc(i, resultRank, resultStrides);\n                const aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n                const bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n                result[i] = op(aVals[aIndex], bVals[bIndex]);\n            }\n        }\n        return [result, newShape];\n    };\n}\n//# sourceMappingURL=binary_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Add } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/kernel_utils';\nexport const addImpl = createSimpleBinaryKernelImpl(((a, b) => a + b));\nexport const addComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return { real: aReal + bReal, imag: aImag + bImag };\n}));\nexport const add = binaryKernelFunc(Add, addImpl, addComplexImpl);\nexport const addConfig = {\n    kernelName: Add,\n    backendName: 'cpu',\n    kernelFunc: add\n};\n//# sourceMappingURL=Add.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for unary op.\n */\nexport function createSimpleUnaryImpl(op) {\n    return (values, dtype, attrs) => {\n        const newValues = util.getTypedArrayFromDType(dtype, values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return newValues;\n    };\n}\n//# sourceMappingURL=unary_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Ceil } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));\nexport const ceil = unaryKernelFuncFromImpl(Ceil, ceilImpl);\nexport const ceilConfig = {\n    kernelName: Ceil,\n    backendName: 'cpu',\n    kernelFunc: ceil,\n};\n//# sourceMappingURL=Ceil.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Exp } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));\nexport const exp = unaryKernelFuncFromImpl(Exp, expImpl);\nexport const expConfig = {\n    kernelName: Exp,\n    backendName: 'cpu',\n    kernelFunc: exp,\n};\n//# sourceMappingURL=Exp.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Expm1 } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));\nexport const expm1 = unaryKernelFuncFromImpl(Expm1, expm1Impl);\nexport const expm1Config = {\n    kernelName: Expm1,\n    backendName: 'cpu',\n    kernelFunc: expm1,\n};\n//# sourceMappingURL=Expm1.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Floor } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));\nexport const floor = unaryKernelFuncFromImpl(Floor, floorImpl);\nexport const floorConfig = {\n    kernelName: Floor,\n    backendName: 'cpu',\n    kernelFunc: floor,\n};\n//# sourceMappingURL=Floor.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Log } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));\nexport const log = unaryKernelFuncFromImpl(Log, logImpl);\nexport const logConfig = {\n    kernelName: Log,\n    backendName: 'cpu',\n    kernelFunc: log,\n};\n//# sourceMappingURL=Log.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Multiply } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/kernel_utils';\nexport const multiplyImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => aValue * bValue));\nexport const multiplyComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return {\n        real: aReal * bReal - aImag * bImag,\n        imag: aReal * bImag + aImag * bReal\n    };\n}));\nexport const multiply = binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);\nexport const multiplyConfig = {\n    kernelName: Multiply,\n    backendName: 'cpu',\n    kernelFunc: multiply\n};\n//# sourceMappingURL=Multiply.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { NotEqual } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/kernel_utils';\nexport const notEqualImpl = createSimpleBinaryKernelImpl(((a, b) => (a !== b) ? 1 : 0));\nexport const notEqual = binaryKernelFunc(NotEqual, notEqualImpl, null /* complexOp */, 'bool');\nexport const notEqualConfig = {\n    kernelName: NotEqual,\n    backendName: 'cpu',\n    kernelFunc: notEqual\n};\n//# sourceMappingURL=NotEqual.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Rsqrt } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));\nexport const rsqrt = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);\nexport const rsqrtConfig = {\n    kernelName: Rsqrt,\n    backendName: 'cpu',\n    kernelFunc: rsqrt,\n};\n//# sourceMappingURL=Rsqrt.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { SquaredDifference } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/kernel_utils';\nexport const squaredDifferenceImpl = createSimpleBinaryKernelImpl(((a, b) => {\n    const diff = a - b;\n    return diff * diff;\n}));\nexport const squaredDifference = binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);\nexport const squaredDifferenceConfig = {\n    kernelName: SquaredDifference,\n    backendName: 'cpu',\n    kernelFunc: squaredDifference\n};\n//# sourceMappingURL=SquaredDifference.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sub } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/kernel_utils';\nexport const subImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => aValue - bValue));\nexport const subComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return { real: aReal - bReal, imag: aImag - bImag };\n}));\nexport const sub = binaryKernelFunc(Sub, subImpl, subComplexImpl);\nexport const subConfig = {\n    kernelName: Sub,\n    backendName: 'cpu',\n    kernelFunc: sub\n};\n//# sourceMappingURL=Sub.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Abs, util } from '@tensorflow/tfjs-core';\nexport function simpleAbsImpl(vals) {\n    const resultValues = new Float32Array(vals.length);\n    for (let i = 0; i < vals.length; ++i) {\n        resultValues[i] = Math.abs(vals[i]);\n    }\n    return resultValues;\n}\nexport const abs = (args) => {\n    const { x } = args.inputs;\n    const cpuBackend = args.backend;\n    let resultValues = new Float32Array(util.sizeFromShape(x.shape));\n    if (x.dtype !== 'complex64') {\n        const values = cpuBackend.data.get(x.dataId).values;\n        resultValues = simpleAbsImpl(values);\n    }\n    else {\n        const complexVals = cpuBackend.data.get(x.dataId);\n        const real = complexVals.complexTensorInfos.real;\n        const imag = complexVals.complexTensorInfos.imag;\n        const realVals = cpuBackend.data.get(real.dataId).values;\n        const imagVals = cpuBackend.data.get(imag.dataId).values;\n        for (let i = 0; i < realVals.length; i++) {\n            const real = realVals[i];\n            const imag = imagVals[i];\n            resultValues[i] = Math.hypot(real, imag);\n        }\n    }\n    return cpuBackend.makeOutput(resultValues, x.shape, 'float32');\n};\nexport const absConfig = {\n    kernelName: Abs,\n    backendName: 'cpu',\n    kernelFunc: abs,\n};\n//# sourceMappingURL=Abs.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function maxImpl(aVals, reduceSize, outShape, dtype) {\n    const vals = util.getTypedArrayFromDType(dtype, util.sizeFromShape(outShape));\n    for (let i = 0; i < vals.length; ++i) {\n        const offset = i * reduceSize;\n        let max = aVals[offset];\n        for (let j = 0; j < reduceSize; ++j) {\n            const value = aVals[offset + j];\n            if (value > max) {\n                max = value;\n            }\n        }\n        vals[i] = max;\n    }\n    return vals;\n}\n//# sourceMappingURL=Max_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function sliceImpl(vals, begin, size, shape, dtype) {\n    const isContinous = slice_util.isSliceContinous(shape, begin, size);\n    const length = util.sizeFromShape(size);\n    const xStrides = util.computeStrides(shape);\n    if (isContinous) {\n        const flatOffset = slice_util.computeFlatOffset(begin, xStrides);\n        return vals.subarray(flatOffset, flatOffset + length);\n    }\n    const outVals = util.getTypedArrayFromDType(dtype, length);\n    for (let i = 0; i < length; ++i) {\n        const rank = size.length;\n        const strides = util.computeStrides(size);\n        const loc = util.indexToLoc(i, rank, strides);\n        const xLoc = loc.map((idx, j) => idx + begin[j]);\n        const xIndex = util.locToIndex(xLoc, shape.length, xStrides);\n        outVals[i] = vals[xIndex];\n    }\n    return outVals;\n}\nexport function slice(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { begin, size } = attrs;\n    assertNotComplex(x, 'slice');\n    const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n    slice_util.assertParamsValid(x, $begin, $size);\n    const vals = backend.data.get(x.dataId).values;\n    const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outVals);\n}\nexport const sliceConfig = {\n    kernelName: Slice,\n    backendName: 'cpu',\n    kernelFunc: slice\n};\n//# sourceMappingURL=Slice.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function transposeImpl(xVals, xShape, dtype, perm, newShape) {\n    const xRank = xShape.length;\n    const xSize = util.sizeFromShape(xShape);\n    const xStrides = util.computeStrides(xShape);\n    const newStrides = util.computeStrides(newShape);\n    const result = util.getTypedArrayFromDType(dtype, util.sizeFromShape(newShape));\n    for (let i = 0; i < xSize; ++i) {\n        const loc = util.indexToLoc(i, xRank, xStrides);\n        // Permute location.\n        const newLoc = new Array(loc.length);\n        for (let i = 0; i < newLoc.length; i++) {\n            newLoc[i] = loc[perm[i]];\n        }\n        const newIndex = util.locToIndex(newLoc, xRank, newStrides);\n        result[newIndex] = xVals[i];\n    }\n    return result;\n}\n//# sourceMappingURL=Transpose_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TensorBuffer, util } from '@tensorflow/tfjs-core';\nexport function uniqueImpl(values, axis, shape, dtype) {\n    // Normalize and validate axis.\n    const $axis = util.parseAxisParam(axis, shape)[0];\n    // Calculate the new shape that is suitable for extracting data along the\n    // given axis.\n    //\n    // The rank is 3.\n    // The size of the 1st dimension is the size of all the axes < the given axis.\n    // The size of the 2nd dimension is the same as the size of the given axis.\n    // The size of the 3rd dimension is the size of all the axes > the given axis.\n    //\n    // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the\n    // newShape would be: [2*3, 5, 4].\n    //\n    // Note that this is not the final output shape. This will be the shape for an\n    // intermediate TensorBuffer (see inputBuffer below) to allow us to extract\n    // values along the given axis. To demonstrate how it works, consider the\n    // following example:\n    //\n    // Input: a 3D tensor, with shape [1, 2, 3]\n    // [\n    //   [\n    //      [1,2,3],\n    //      [4,5,6]\n    //   ]\n    // ]\n    // Axis: 2 (the last axis).\n    // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].\n    //\n    // For this example, newShape would be: [2, 3, 1], where 2 is calculated from\n    // 1*2. The re-shaped data would look like:\n    //\n    // [\n    //   [\n    //     [1], [2], [3]\n    //   ],\n    //   [\n    //     [4], [5], [6]\n    //   ]\n    // ]\n    //\n    // Then, we can construct a 3-level nested loop by the following dimension\n    // order to extract the values along the axis (dimension1):\n    // i: dimension1       // 0,1,2 (newShape[1])\n    //   m: dimension0     // 0,1   (newShape[0])\n    //     n: dimension2   // 0     (newShape[2])\n    //\n    //                       m, i, n\n    //                      ---------\n    // Iteration 0: data at [0, 0, 0] => \"1\"\n    // Iteration 1: data at [1, 0, 0] => \"4\"\n    // We got [1,4].\n    // Iteration 2: data at [0, 1, 0] => \"2\"\n    // Iteration 3: data at [1, 1, 0] => \"5\"\n    // We got [2,5].\n    // Iteration 4: data at [0, 2, 0] => \"3\"\n    // Iteration 5: data at [1, 2, 0] => \"6\"\n    // We got [3,6].\n    const newShape = [1, shape[0], 1];\n    for (let i = 0; i < $axis; i++) {\n        newShape[0] *= shape[i];\n    }\n    newShape[1] = shape[$axis];\n    for (let i = $axis + 1; i < shape.length; i++) {\n        newShape[2] *= shape[i];\n    }\n    // A map from unique elements (their string representations) to their values\n    // in \"indices\" (below).\n    const uniqueElements = {};\n    // The indices of each unique element in the original tensor along the given\n    // axis. It is 1D and has the same size as the given axis.\n    const indices = new Int32Array(shape[$axis]);\n    // Create a buffer so we can easily extract value at a given location.\n    const inputBuffer = new TensorBuffer(newShape, dtype, values);\n    // The indices along the given axis that have unique elements. This is a\n    // de-duped version of \"indices\" above.\n    const uniqueIndices = [];\n    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;\n    for (let i = 0; i < shape[$axis]; i++) {\n        // Extract values along the axis.\n        let element;\n        if (is1DTensor) {\n            // Fast path for 1D tensor input.\n            element = values[i].toString();\n        }\n        else {\n            const axisValues = [];\n            for (let m = 0; m < newShape[0]; m++) {\n                for (let n = 0; n < newShape[2]; n++) {\n                    axisValues.push(inputBuffer.get(m, i, n));\n                }\n            }\n            element = axisValues.join(',');\n        }\n        // Dedup and update various indices.\n        if (uniqueElements[element] !== undefined) {\n            indices[i] = uniqueElements[element];\n        }\n        else {\n            const uniqueIndex = Object.keys(uniqueElements).length;\n            uniqueElements[element] = uniqueIndex;\n            indices[i] = uniqueIndex;\n            uniqueIndices.push(i);\n        }\n    }\n    // Now we know where each of the unique elements are located along the axis\n    // (uniqueIndices). Extract them from input buffer and store them in the\n    // output buffer.\n    const outputTmpShape = newShape.slice();\n    outputTmpShape[1] = Object.keys(uniqueElements).length;\n    const outputBuffer = new TensorBuffer(outputTmpShape, dtype);\n    uniqueIndices.forEach((uniqueElementIndex, i) => {\n        for (let m = 0; m < newShape[0]; m++) {\n            for (let n = 0; n < newShape[2]; n++) {\n                outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);\n            }\n        }\n    });\n    // The output shape can be calculated from the input shape with the size of\n    // the given axis replaced by the number of unique elements along that axis.\n    const outputShape = shape.slice();\n    outputShape[$axis] = outputTmpShape[1];\n    return {\n        outputValues: outputBuffer.values,\n        outputShape,\n        indices,\n    };\n}\n//# sourceMappingURL=Unique_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import shared functionality from tfjs-backend-cpu without triggering\n// side effects.\n// tslint:disable-next-line: no-imports-from-dist\nimport * as shared from '@tensorflow/tfjs-backend-cpu/dist/shared';\n// tslint:disable-next-line: no-imports-from-dist\nimport {SimpleBinaryKernelImpl} from '@tensorflow/tfjs-backend-cpu/dist/shared';\n\nexport type SimpleBinaryKernelImplCPU = SimpleBinaryKernelImpl;\nconst {\n  simpleAbsImpl: simpleAbsImplCPU,\n  addImpl: addImplCPU,\n  ceilImpl: ceilImplCPU,\n  expImpl: expImplCPU,\n  expm1Impl: expm1ImplCPU,\n  floorImpl: floorImplCPU,\n  logImpl: logImplCPU,\n  maxImpl: maxImplCPU,\n  multiplyImpl: multiplyImplCPU,\n  rsqrtImpl: rsqrtImplCPU,\n  sliceImpl: sliceImplCPU,\n  subImpl: subImplCPU,\n  transposeImpl: transposeImplCPU,\n  uniqueImpl: uniqueImplCPU,\n} = shared;\n\nexport {\n  simpleAbsImplCPU,\n  addImplCPU,\n  ceilImplCPU,\n  expImplCPU,\n  expm1ImplCPU,\n  logImplCPU,\n  multiplyImplCPU,\n  sliceImplCPU,\n  subImplCPU,\n  floorImplCPU,\n  maxImplCPU,\n  rsqrtImplCPU,\n  transposeImplCPU,\n  uniqueImplCPU,\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AddNProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(outputShape: number[], shapes: number[][]) {\n    this.outputShape = outputShape;\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`float v${variable} = get${variable}AtOutCoords();`);\n    });\n\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        float result = ${operation};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AddNPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(outputShape: number[], shapes: number[][]) {\n    this.outputShape = outputShape;\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);\n    });\n\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        vec4 result = ${operation};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ArgMinMaxProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo, op: 'max'|'min',\n      firstPass: boolean) {\n    const {windowSize, batchSize, outSize} = reduceInfo;\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n    this.outputShape = [batchSize, outSize];\n    const compOp = (op === 'max') ? '>' : '<';\n    const indexSnippet = firstPass ?\n        'inOffset + i;' :\n        'round(getBestIndicesA(batch, inOffset + i));';\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          int inIdx = ${indexSnippet};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${compOp} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport function getVecChannels(name: string, rank: number): string[] {\n  return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);\n}\n\nexport function getChannels(name: string, rank: number): string[] {\n  if (rank === 1) {\n    return [name];\n  }\n  return getVecChannels(name, rank);\n}\n\nexport function getSourceCoords(rank: number, dims: string[]): string {\n  if (rank === 1) {\n    return 'rc';\n  }\n\n  let coords = '';\n  for (let i = 0; i < rank; i++) {\n    coords += dims[i];\n    if (i < rank - 1) {\n      coords += ',';\n    }\n  }\n  return coords;\n}","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {env} from '@tensorflow/tfjs-core';\n\nexport type GLSL = {\n  version: string,\n  attribute: string,\n  varyingVs: string,\n  varyingFs: string,\n  texture2D: string,\n  output: string,\n  defineOutput: string,\n  defineSpecialNaN: string,\n  defineSpecialInf: string,\n  defineRound: string\n};\n\nexport function getGlslDifferences(): GLSL {\n  let version: string;\n  let attribute: string;\n  let varyingVs: string;\n  let varyingFs: string;\n  let texture2D: string;\n  let output: string;\n  let defineOutput: string;\n  let defineSpecialNaN: string;\n  let defineSpecialInf: string;\n  let defineRound: string;\n\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    version = '#version 300 es';\n    attribute = 'in';\n    varyingVs = 'out';\n    varyingFs = 'in';\n    texture2D = 'texture';\n    output = 'outputColor';\n    defineOutput = 'out vec4 outputColor;';\n\n    // Use custom isnan definition to work across differences between\n    // implementations on various platforms. While this should happen in ANGLE\n    // we still see differences between android and windows (on chrome) when\n    // using isnan directly.\n    defineSpecialNaN = `\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;\n    // In webgl 2 we do not need to specify a custom isinf so there is no\n    // need for a special INFINITY constant.\n    defineSpecialInf = ``;\n    defineRound = `\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n  } else {\n    version = '';\n    attribute = 'attribute';\n    varyingVs = 'varying';\n    varyingFs = 'varying';\n    texture2D = 'texture2D';\n    output = 'gl_FragColor';\n    defineOutput = '';\n    // WebGL1 has no built in isnan so we define one here.\n    defineSpecialNaN = `\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;\n    defineSpecialInf = `\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;\n    defineRound = `\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n  }\n\n  return {\n    version,\n    attribute,\n    varyingVs,\n    varyingFs,\n    texture2D,\n    output,\n    defineOutput,\n    defineSpecialNaN,\n    defineSpecialInf,\n    defineRound\n  };\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(\n    coords: string[], shape: number[], index = 'index'): string {\n  const strides = util.computeStrides(shape);\n  return strides\n      .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\nfunction buildVec(x: string[]): string {\n  if (x.length === 1) {\n    return `${x[0]}`;\n  }\n  return `vec${x.length}(${x.join(',')})`;\n}\n\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x: string[], y: string[]): string {\n  if (x.length !== y.length) {\n    throw new Error(\n        `Vectors to be dotted must be of the same length -` +\n        `got ${x.length} and ${y.length}`);\n  }\n\n  const slices: string[] = [];\n  const nearestVec4 = Math.floor(x.length / 4);\n  const nearestVec4Remainder = x.length % 4;\n\n  for (let i = 0; i < nearestVec4; i++) {\n    const xSlice = x.slice(i * 4, i * 4 + 4);\n    const ySlice = y.slice(i * 4, i * 4 + 4);\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  if (nearestVec4Remainder !== 0) {\n    let xSlice = x.slice(nearestVec4 * 4);\n    let ySlice = y.slice(nearestVec4 * 4);\n    if (xSlice.length === 1) {\n      xSlice = xSlice.map(d => `float(${d})`);\n      ySlice = ySlice.map(d => `float(${d})`);\n    }\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  return slices.map((d, i) => `dot(${d})`).join('+');\n}\n\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape: [number, number, number]): string {\n  const strides = util.computeStrides(shape).map(d => d.toString());\n\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\n\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nconst {getBroadcastDims} = backend_util;\nimport {getGlslDifferences, GLSL} from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\n\nexport type ShapeInfo = {\n  logicalShape: number[],\n  texShape: [number, number],\n  isUniform: boolean,\n  isPacked: boolean,\n  flatOffset: number\n};\n\nexport type InputInfo = {\n  name: string,\n  shapeInfo: ShapeInfo\n};\n\nexport function makeShader(\n    inputsInfo: InputInfo[], outputShape: ShapeInfo, userCode: string,\n    usesPackedTextures: boolean): string {\n  const prefixSnippets: string[] = [];\n  inputsInfo.forEach(x => {\n    const size = util.sizeFromShape(x.shapeInfo.logicalShape);\n\n    // Snippet when we decided to upload the values as uniform.\n    if (x.shapeInfo.isUniform) {\n      prefixSnippets.push(\n          `uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);\n    } else {\n      prefixSnippets.push(`uniform sampler2D ${x.name};`);\n      prefixSnippets.push(`uniform int offset${x.name};`);\n    }\n  });\n  const inputPrefixSnippet = prefixSnippets.join('\\n');\n\n  const inputSamplingSnippet =\n      inputsInfo\n          .map(x => getInputSamplingSnippet(x, outputShape, usesPackedTextures))\n          .join('\\n');\n  const outTexShape = outputShape.texShape;\n  const glsl = getGlslDifferences();\n  const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);\n  let outputSamplingSnippet: string;\n  let floatTextureSetOutputSnippet: string;\n  let shaderPrefix = getShaderPrefix(glsl);\n\n  if (outputShape.isPacked) {\n    outputSamplingSnippet =\n        getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n    floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);\n  } else {\n    outputSamplingSnippet =\n        getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n    floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);\n  }\n\n  if (usesPackedTextures) {\n    shaderPrefix += SHADER_PACKED_PREFIX;\n  }\n\n  const source = [\n    shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,\n    inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode\n  ].join('\\n');\n  return source;\n}\n\nfunction getSamplerFromInInfo(inInfo: InputInfo): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getSamplerScalar(inInfo);\n    case 1:\n      return getSampler1D(inInfo);\n    case 2:\n      return getSampler2D(inInfo);\n    case 3:\n      return getSampler3D(inInfo);\n    case 4:\n      return getSampler4D(inInfo);\n    case 5:\n      return getSampler5D(inInfo);\n    case 6:\n      return getSampler6D(inInfo);\n    default:\n      throw new Error(\n          `${shape.length}-D input sampling` +\n          ` is not yet supported`);\n  }\n}\n\nfunction getPackedSamplerFromInInfo(inInfo: InputInfo): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getPackedSamplerScalar(inInfo);\n    case 1:\n      return getPackedSampler1D(inInfo);\n    case 2:\n      return getPackedSampler2D(inInfo);\n    case 3:\n      return getPackedSampler3D(inInfo);\n    default:\n      return getPackedSamplerND(inInfo);\n  }\n}\n\nfunction getInputSamplingSnippet(\n    inInfo: InputInfo, outShapeInfo: ShapeInfo,\n    usesPackedTextures = false): string {\n  let res = '';\n  if (usesPackedTextures) {\n    res += getPackedSamplerFromInInfo(inInfo);\n  } else {\n    res += getSamplerFromInInfo(inInfo);\n  }\n\n  const inShape = inInfo.shapeInfo.logicalShape;\n  const outShape = outShapeInfo.logicalShape;\n  if (inShape.length <= outShape.length) {\n    if (usesPackedTextures) {\n      res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);\n    } else {\n      res += getSamplerAtOutputCoords(inInfo, outShapeInfo);\n    }\n  }\n  return res;\n}\n\nfunction getPackedOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number]): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutputPacked1DCoords(outShape as [number], outTexShape);\n    case 2:\n      return getOutputPacked2DCoords(outShape as [number, number], outTexShape);\n    case 3:\n      return getOutputPacked3DCoords(\n          outShape as [number, number, number], outTexShape);\n    default:\n      return getOutputPackedNDCoords(outShape, outTexShape);\n  }\n}\n\nfunction getOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number]): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutput1DCoords(outShape as [number], outTexShape);\n    case 2:\n      return getOutput2DCoords(outShape as [number, number], outTexShape);\n    case 3:\n      return getOutput3DCoords(\n          outShape as [number, number, number], outTexShape);\n    case 4:\n      return getOutput4DCoords(\n          outShape as [number, number, number, number], outTexShape);\n    case 5:\n      return getOutput5DCoords(\n          outShape as [number, number, number, number, number], outTexShape);\n    case 6:\n      return getOutput6DCoords(\n          outShape as [number, number, number, number, number, number],\n          outTexShape);\n    default:\n      throw new Error(\n          `${outShape.length}-D output sampling is not yet supported`);\n  }\n}\n\nfunction getFloatTextureSampleSnippet(glsl: GLSL): string {\n  return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${glsl.texture2D}(textureSampler, uv).r;\n    }\n  `;\n}\n\nfunction getFloatTextureSetRSnippet(glsl: GLSL): string {\n  return `\n    void setOutput(float val) {\n      ${glsl.output} = vec4(val, 0, 0, 0);\n    }\n  `;\n}\n\nfunction getFloatTextureSetRGBASnippet(glsl: GLSL): string {\n  return `\n    void setOutput(vec4 val) {\n      ${glsl.output} = val;\n    }\n  `;\n}\n\nfunction getShaderPrefix(glsl: GLSL): string {\n  const SHADER_PREFIX = `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFs} vec2 resultUV;\n    ${glsl.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${glsl.defineSpecialNaN}\n    ${glsl.defineSpecialInf}\n    ${glsl.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;\n\n  return SHADER_PREFIX;\n}\n\nconst SAMPLE_1D_SNIPPET = `\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_2D_SNIPPET = `\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_3D_SNIPPET = `\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SHADER_PACKED_PREFIX = `\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;\n\nfunction getOutputScalarCoords() {\n  return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;\n}\n\nfunction getOutputPacked1DCoords(\n    shape: [number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  if (packedTexShape[0] === 1) {\n    return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);\n      }\n    `;\n  }\n\n  if (packedTexShape[1] === 1) {\n    return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);\n      }\n    `;\n  }\n\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);\n    }\n  `;\n}\n\nfunction getOutput1DCoords(\n    shape: [number], texShape: [number, number]): string {\n  if (texShape[0] === 1) {\n    return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${texShape[1]}.0);\n      }\n    `;\n  }\n  if (texShape[1] === 1) {\n    return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${texShape[0]}.0);\n      }\n    `;\n  }\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      return resTexRC.x * ${texShape[1]} + resTexRC.y;\n    }\n  `;\n}\n\nfunction getOutputPacked3DCoords(\n    shape: [number, number, number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n  const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;\n}\n\nfunction getOutput3DCoords(\n    shape: [number, number, number], texShape: [number, number]): string {\n  const coordsFromIndexSnippet =\n      shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n\nfunction getOutputPackedNDCoords(\n    shape: number[], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n\n  const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n  const texelsInBatch =\n      texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n  let texelsInBatchN = texelsInBatch;\n  let batches = ``;\n  let coords = 'b, r, c';\n\n  for (let b = 2; b < shape.length - 1; b++) {\n    texelsInBatchN *= shape[shape.length - b - 1];\n    batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n    coords = `b${b}, ` + coords;\n  }\n\n  return `\n    ivec${shape.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      ${batches}\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec${shape.length}(${coords});\n    }\n  `;\n}\n\nfunction getOutput4DCoords(\n    shape: [number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2'], shape);\n\n  return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec4(r, c, d, d2);\n    }\n  `;\n}\n\nfunction getOutput5DCoords(\n    shape: [number, number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2', 'd3'], shape);\n\n  return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},\n                             ${texShape[1]}));\n\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `;\n}\n\nfunction getOutput6DCoords(\n    shape: [number, number, number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);\n\n  return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `;\n}\n\nfunction getOutputPacked2DCoords(\n    shape: [number, number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  if (util.arraysEqual(shape, texShape)) {\n    return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${\n        packedTexShape[1]}));\n      }\n    `;\n  }\n\n  // texels needed to accommodate a logical row\n  const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n\n  /**\n   * getOutputCoords\n   *\n   * resTexRC: The rows and columns of the texels. If you move over one\n   * texel to the right in the packed texture, you are moving over one column\n   * (not two).\n   *\n   * index: The texel index\n   */\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getOutput2DCoords(\n    shape: [number, number], texShape: [number, number]): string {\n  if (util.arraysEqual(shape, texShape)) {\n    return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));\n      }\n    `;\n  }\n  if (shape[1] === 1) {\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n  }\n  if (shape[0] === 1) {\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n  }\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${shape[1]};\n      int c = index - r * ${shape[1]};\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getFlatOffsetUniformName(texName: string): string {\n  return `offset${texName}`;\n}\n\nfunction getPackedSamplerScalar(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const glsl = getGlslDifferences();\n  return `\n    vec4 ${funcName}() {\n      return ${glsl.texture2D}(${texName}, halfCR);\n    }\n  `;\n}\n\nfunction getSamplerScalar(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  if (inputInfo.shapeInfo.isUniform) {\n    return `float ${funcName}() {return ${texName};}`;\n  }\n  const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;\n  if (texNumR === 1 && texNumC === 1) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n\n  const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}() {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getPackedSampler1D(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const glsl = getGlslDifferences();\n\n  return `\n    vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler1D(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int index) {\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const tNumR = texShape[0];\n  const tNumC = texShape[1];\n\n  if (tNumC === 1 && tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n  const offset = getFlatOffsetUniformName(texName);\n  if (tNumC === 1) {\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  return `\n    float ${funcName}(int index) {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getPackedSampler2D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const glsl = getGlslDifferences();\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    return `\n      vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n\n        return ${glsl.texture2D}(${texName}, uv);\n      }\n    `;\n  }\n\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const valuesPerRow = Math.ceil(shape[1] / 2);\n\n  return `\n    vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${\n      packedTexShape[1]}, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler2D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    return `\n    float ${funcName}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const offset = getFlatOffsetUniformName(texName);\n  if (texNumC === 1) {\n    // index is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n  if (texNumR === 1) {\n    // index is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  return `\n  float ${funcName}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${shape[1]} + col + ${offset};\n    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n    return sampleTexture(${texName}, uv);\n  }\n`;\n}\n\nfunction getPackedSampler3D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n\n  if (shape[0] === 1) {\n    const squeezedShape = shape.slice(1);\n    const keptDims = [1, 2];\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['b', 'row', 'col'];\n    return `\n        ${getPackedSamplerFromInInfo(newInputInfo)}\n        vec4 ${funcName}(int b, int row, int col) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  const texNumR = packedTexShape[0];\n  const texNumC = packedTexShape[1];\n\n  const valuesPerRow = Math.ceil(shape[2] / 2);\n  const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n  const glsl = getGlslDifferences();\n\n  return `\n    vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler3D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride0 = shape[1] * shape[2];\n  const stride1 = shape[2];\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col', 'depth'];\n    return `\n        ${getSamplerFromInInfo(newInputInfo)}\n        float ${funcName}(int row, int col, int depth) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${stride0}, ${stride1}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n        float ${funcName}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${texNumC}.0, ${texNumR}.0);\n          return sampleTexture(${texName}, uv);\n        }\n      `;\n  }\n\n  if (texNumC === stride1 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n      float ${funcName}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};\n        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n        return sampleTexture(${texName}, uv);\n      }\n  `;\n}\n\nfunction getPackedSamplerND(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const rank = shape.length;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const texNumR = packedTexShape[0];\n  const texNumC = packedTexShape[1];\n\n  const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n  let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n  let params = `int b, int row, int col`;\n  let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n  for (let b = 2; b < rank - 1; b++) {\n    params = `int b${b}, ` + params;\n    texelsInBatch *= shape[rank - b - 1];\n    index = `b${b} * ${texelsInBatch} + ` + index;\n  }\n  const glsl = getGlslDifferences();\n  return `\n    vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler4D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride2 = shape[3];\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${stride1}, ${stride2}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride2 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} +\n          depth * ${stride2} + depth2;\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler5D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride3 = shape[4];\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          depth3;\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${stride1}, ${stride2}, ${stride3}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  if (texNumC === stride3 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3]},\n               ${shape[2] * shape[3]}, ${shape[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler6D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  const stride4 = shape[5];\n  const stride3 = shape[4] * stride4;\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${stride4}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride4 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},\n               ${shape[2] * shape[3] * shape[4]},\n               ${shape[3] * shape[4]},\n               ${shape[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getUniformSampler(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n\n  if (inSize < 2) {\n    return `return ${texName};`;\n  }\n  return `\n    for (int i = 0; i < ${inSize}; i++) {\n      if (i == index) {\n        return ${texName}[i];\n      }\n    }\n  `;\n}\n\nfunction getPackedSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  const broadcastDims = getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n\n  const type = getCoordsDataType(outRank);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n            .join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords.${fields[i + rankDiff]}`)\n                                .join(', ');\n  }\n\n  let output = `return outputValue;`;\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n  const isInputScalar = inSize === 1;\n  const outSize = util.sizeFromShape(outShapeInfo.logicalShape);\n  const isOutputScalar = outSize === 1;\n\n  if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n    output = `\n      return vec4(outputValue.xy, outputValue.xy);\n    `;\n  } else if (isInputScalar && !isOutputScalar) {\n    if (outRank === 1) {\n      output = `\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `;\n    } else {\n      output = `\n        return vec4(outputValue.x);\n      `;\n    }\n  } else if (broadcastDims.length) {\n    const rows = inRank - 2;\n    const cols = inRank - 1;\n\n    if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n      output = `return vec4(outputValue.x);`;\n    } else if (broadcastDims.indexOf(rows) > -1) {\n      output = `return vec4(outputValue.x, outputValue.y, ` +\n          `outputValue.x, outputValue.y);`;\n    } else if (broadcastDims.indexOf(cols) > -1) {\n      output = `return vec4(outputValue.xx, outputValue.zz);`;\n    }\n  }\n\n  return `\n    vec4 ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});\n      ${output}\n    }\n  `;\n}\n\nfunction getSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n  const outTexShape = outShapeInfo.texShape;\n  const inTexShape = inputInfo.shapeInfo.texShape;\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&\n      inputInfo.shapeInfo.flatOffset == null &&\n      util.arraysEqual(inTexShape, outTexShape)) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, resultUV);\n      }\n    `;\n  }\n\n  const type = getCoordsDataType(outRank);\n  const broadcastDims = getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n            .join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords.${fields[i + rankDiff]}`)\n                                .join(', ');\n  }\n\n  return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return get${texFuncSnippet}(${unpackedCoordsSnippet});\n    }\n  `;\n}\n\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else if (rank === 6) {\n    return 'ivec6';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nfunction squeezeInputInfo(\n    inInfo: InputInfo, squeezedShape: number[]): InputInfo {\n  // Deep copy.\n  const newInputInfo: InputInfo = JSON.parse(JSON.stringify(inInfo));\n  newInputInfo.shapeInfo.logicalShape = squeezedShape;\n  return newInputInfo;\n}\n\nfunction getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map(d => params[d]).join(', ');\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ArgMinMaxPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      shape: number[], windowSize: number, op: 'max'|'min',\n      firstPass: boolean) {\n    util.assert(\n        shape.length > 2,\n        () => `Packed arg${\n            op.charAt(0).toUpperCase() +\n            op.slice(1)} supports only inputs with rank above 2.`);\n    const inSize = shape[shape.length - 1];\n    const outSize = Math.ceil(inSize / windowSize);\n    this.outputShape = shape.slice(0, -1);\n    if (outSize > 1) {\n      this.outputShape.push(outSize);\n    }\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n    const outShape = this.outputShape;\n    const rank = outShape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n\n    let sourceLocSetup;\n    let sourceRank;\n    if (outSize === 1) {\n      sourceRank = rank + 1;\n      const sourceLocDType = getCoordsDataType(sourceRank);\n      sourceLocSetup = `\n        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 1]};\n        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 2]};\n        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 1]};\n        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 2]};`;\n    } else {\n      sourceRank = rank;\n      sourceLocSetup = `\n        ${dtype} sourceLocR = coords;\n        ++${coords[rank - 1]};\n        ${dtype} sourceLocG = coords;\n        ++${coords[rank - 2]};\n        ${dtype} sourceLocA = coords;\n        --${coords[rank - 1]};\n        ${dtype} sourceLocB = coords;\n        --${coords[rank - 2]};`;\n    }\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);\n    const inChannel = '.' + channels[sourceRank - 1];  // e.g. \".b\" for rank 3.\n    const intChannels = channels.map(x => 'int ' + x);\n    const srcRCoords =\n        getChannels('sourceLocR', sourceRank - 1).concat('inIdx.r');\n    const srcGCoords =\n        getChannels('sourceLocG', sourceRank - 1).concat('inIdx.g');\n    const srcBCoords =\n        getChannels('sourceLocB', sourceRank - 1).concat('inIdx.b');\n    const srcACoords =\n        getChannels('sourceLocA', sourceRank - 1).concat('inIdx.a');\n\n    const compOp = (op === 'max') ? 'greaterThan' : 'lessThan';\n    const fetchCandidateIdx = firstPass ? '' : `\n          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),\n                             getBestIndicesAChannel(${srcGCoords.join()}),\n                             getBestIndicesAChannel(${srcBCoords.join()}),\n                             getBestIndicesAChannel(${srcACoords.join()})));`;\n\n    const fetchValue = `vec4(\n            getAChannel(${srcRCoords.join()}),\n            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,\n            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;\n\n    const getBestIndicesAChannelSnippet = firstPass ? '' : `\n      float getBestIndicesAChannel(${intChannels.join()}) {\n        return getChannel(getBestIndicesA(${channels.join()}),\n                                          vec2(${channels.slice(-2).join()}));\n      }`;\n\n    this.userCode = `\n      float getAChannel(${intChannels.join()}) {\n        return getChannel(getA(${channels.join()}),\n                               vec2(${channels.slice(-2).join()}));\n      }\n      ${getBestIndicesAChannelSnippet}\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};\n        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};\n        ${sourceLocSetup}\n        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},\n          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${fetchValue};\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          inIdx = srcIdx;\n          ${fetchCandidateIdx}\n          vec4 candidate = ${fetchValue};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AvgPool2DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const avgMultiplier = 1 / (filterHeight * filterWidth);\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth};\n            wC+= ${dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class AvgPool3DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nconst CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\n\n// We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\nexport const INT_DIV = `\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;\n\nexport const POW = `\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\n\nexport const EQUAL = `return float(a == b);`;\n\nexport const LESS = `return float(a < b);`;\n\nexport const LESS_EQUAL = `return float(a <= b);`;\n\nexport const GREATER = `return float(a > b);`;\n\nexport const GREATER_EQUAL = `return float(a >= b);`;\n\nexport const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\n\nexport const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\n\nexport const MAX = CHECK_NAN_SNIPPET + `\n  return max(a, b);\n`;\nexport const MIN = CHECK_NAN_SNIPPET + `\n  return min(a, b);\n`;\nexport const MOD = `if (b == 0.0) return NAN;\n  return mod(a, b);`;\n\nexport const ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\n\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\n\nexport class BinaryOpProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(op: string, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${op}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nconst CHECK_NAN_SNIPPET = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n\nexport const INT_DIV = `\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`;\n\nexport const POW = `\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const PRELU = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\n\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\n\nexport const EQUAL = `\n  return vec4(equal(a, b));\n`;\n\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\n\nexport const LESS = `\n  return vec4(lessThan(a, b));\n`;\n\nexport const LESS_EQUAL = `\n  return vec4(lessThanEqual(a, b));\n`;\n\nexport const GREATER = `\n  return vec4(greaterThan(a, b));\n`;\n\nexport const GREATER_EQUAL = `\n  return vec4(greaterThanEqual(a, b));\n`;\n\nexport const LOGICAL_AND = `\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`;\n\nexport const LOGICAL_OR = `\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`;\n\nexport const MAX = `\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const MIN = `\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const MOD = `\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport class BinaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n  supportsBroadcasting = true;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      op: string, aShape: number[], bShape: number[],\n      checkOutOfBounds = false) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const rank = this.outputShape.length;\n    let checkOutOfBoundsString = '';\n    if (checkOutOfBounds) {\n      if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n        checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n      } else {\n        const dtype = getCoordsDataType(rank);\n        checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n        if (rank === 1) {\n          checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n        } else {\n          const channels = getChannels('coords', rank);\n          checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n        }\n      }\n    }\n\n    this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ClipProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  // Caching uniform locations for speed.\n  minLoc: WebGLUniformLocation;\n  maxLoc: WebGLUniformLocation;\n\n  constructor(aShape: number[]) {\n    this.outputShape = aShape;\n    this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(min: number, max: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.minLoc == null) {\n        this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n        this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n      }\n      gpgpu.gl.uniform1f(this.minLoc, min);\n      gpgpu.gl.uniform1f(this.maxLoc, max);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ClipPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  userCode: string;\n  outputShape: number[];\n\n  // Caching uniform locations for speed.\n  minLoc: WebGLUniformLocation;\n  maxLoc: WebGLUniformLocation;\n\n  constructor(aShape: number[]) {\n    this.outputShape = aShape;\n    this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(min: number, max: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.minLoc == null) {\n        this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n        this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n      }\n      gpgpu.gl.uniform1f(this.minLoc, min);\n      gpgpu.gl.uniform1f(this.maxLoc, max);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ComplexAbsProgram implements GPGPUProgram {\n  variableNames = ['real', 'imag'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n    this.userCode = `\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Conv2DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              if (${isChannelsLast}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv2DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv3DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n\n    this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv3DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n\n    const padFront = filterDepth - 1 - convInfo.padInfo.front;\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConv2DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class DepthwiseConv2DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Conv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivationWeights = false) {\n    this.outputShape = convInfo.outShape;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n\nexport class Conv3DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.outShape;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n\n    this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${\n        strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false) {\n    this.outputShape = convInfo.outShape;\n\n    const xNumRows = convInfo.inHeight;\n    const xNumCols = convInfo.inWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${xNumRows}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${xNumCols}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConvPacked2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false) {\n    this.outputShape = convInfo.outShape;\n\n    const xNumRows = convInfo.inHeight;\n    const xNumCols = convInfo.inWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const texelsAcross = filterWidth;\n\n    let mainLoop = `int xR; int xC; int xCOffset;`;\n\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `\n          vec4 xTexelR${r}C${c * 2} = vec4(0.);\n          vec4 wR${r}C${c} = vec4(0.);\n          vec4 xR${r}C${c} = vec4(0.);`;\n      }\n    }\n\n    /**\n     * This vectorized implementation works by gathering the values needed for\n     * each output channel's dot product into vec4's and then multiplying them\n     * all together (this happens in the final double for-loop below). Most of\n     * the main loop consists of constructing these vec4's with the minimum\n     * number of texture2D calls, which means making use of all four returned\n     * values from a texture2D call at once.\n     */\n    for (let r = 0; r < filterHeight; r++) {\n      for (let texelC = 0; texelC < texelsAcross; texelC++) {\n        const c = texelC * 2;\n\n        mainLoop += `\n          xR = xRCorner + ${r * dilationHeight};\n          xC = xCCorner + ${c * dilationWidth};\n        `;\n\n        if (strideWidth === 1) {\n          if (c < filterWidth) {\n            // If padding is odd, the outer texels have to be composed.\n            if (padLeft % 2 === 1) {\n              // TODO: Ensure vec4 previous does not result in redundant sample,\n              // and avoid setting xTexelRC's that exceed the boundary in the\n              // first place rather than resetting them to vec4(0)).\n\n              // To compute xCOffset:\n              // - If padding is odd, we must add 1 to ensure we ask for an\n              // even-numbered row.\n              // - We subtract 2 to access the previous texel.\n\n              mainLoop += `\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${\n                  xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    xTexelR${r}C${c}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${\n                  xNumCols}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);\n                } else {\n                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);\n                }\n              `;\n            } else {\n              // Padding is even, so xRC corresponds to a single texel.\n              mainLoop += `\n                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xR${r}C${c} = xTexelR${r}C${c};\n              `;\n            }\n\n            if (c + 1 < filterWidth) {\n              // If dilation is even, the second entry should match the first\n              // (either both are composed or both are single samples). But if\n              // dilation is odd, then the second entry should be the opposite\n              // of the first (if the first is composed, the second is a single\n              // sample, and vice versa.)\n\n              const nextTexelOffset = padLeft % 2 === 0 ?\n                  util.nearestLargerEven(dilationWidth) :\n                  dilationWidth;\n\n              if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                  (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                mainLoop += `\n                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `;\n\n                // If dilation > 1 then the xRC's will not be able to share any\n                // values, so each xRC will require two unique calls to getX.\n                if (dilationWidth > 1) {\n                  mainLoop += `\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${xNumRows} &&\n                      xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${r}C${c} = vec4(0.);\n                    }\n                  `;\n                }\n\n                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.xy);\n                `;\n              } else {\n                mainLoop += `\n                  xCOffset = xC + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${r}C${c + 1} = xTexelR${r}C${c + 2};\n                `;\n              }\n            }\n          }\n        } else {  // stride > 1\n          if (c < filterWidth) {\n            mainLoop += `\n              if(xR >= 0 && xR < ${xNumRows}) {\n            `;\n\n            // Depending on whether padLeft is even or odd, we want either the\n            // xy or zw channels from X texels for xR${r}C${c}. If padLeft is\n            // even, xR${r}C${c + 1} is simply the zw channels of texels we've\n            // already sampled. But if padLeft is odd, xR${r}C{$c + 1}.zw will\n            // need to come from the xy channels of a new texel, hence the `vec4\n            // final` initialized below.\n            if (padLeft % 2 === 1) {\n              mainLoop += `\n                xCOffset = xC + 1 - ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n              `;\n\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${strideWidth};\n                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${r}C${c + 1} = vec4(xTexelR${r}C${c + 2}.xy, final.xy);\n                `;\n              }\n            } else {\n              mainLoop += `\n                if(xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.xy, xTexelR${r}C${c + 2}.xy);\n              `;\n\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n                `;\n              }\n            }\n\n            mainLoop += `}`;\n          }\n        }\n\n        if (c < filterWidth) {\n          mainLoop += `\n            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);\n            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);\n          `;\n\n          if (c + 1 < filterWidth) {\n            mainLoop += `\n              vec4 wTexelR${r}C${c + 1} = getW(${r}, ${c + 1}, d1, q);\n              wR${r}C${c + 1} =\n                vec4(wTexelR${r}C${c + 1}.xz, wTexelR${r}C${c + 1}.xz);`;\n          }\n        }\n      }\n    }\n\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `dotProd += xR${r}C${c} * wR${r}C${c};`;\n      }\n    }\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${mainLoop}\n\n        vec4 result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class CropAndResizeProgram implements GPGPUProgram {\n  variableNames = ['Image', 'Boxes', 'BoxInd'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      imageShape: [number, number, number, number], boxShape: [number, number],\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number) {\n    const [batch, imageHeight, imageWidth, depth] = imageShape;\n    const [numBoxes, ] = boxShape;\n    const [cropHeight, cropWidth] = cropSize;\n    this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n    const methodId = method === 'bilinear' ? 1 : 0;\n\n    const [inputHeightFloat, inputWidthFloat] =\n        [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n\n    const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n        [\n          `${(imageHeight - 1) / (cropHeight - 1)}`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n        [\n          `${(imageWidth - 1) / (cropWidth - 1)}`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class CumSumProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  index: WebGLUniformLocation;\n\n  constructor(shape: number[], exclusive: boolean, reverse: boolean) {\n    this.outputShape = shape;\n    const rank = shape.length;\n    const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n    const length = shape[shape.length - 1];\n    let condition = '';\n    let idxString = '';\n    // When exclusive is set, the cumsum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = (reverse ? 'end + pow2' : 'end - pow2');\n    }\n\n    this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(index: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.index == null) {\n        this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n      }\n      gpgpu.gl.uniform1f(this.index, index);\n    };\n  }\n}\n\nfunction getCoords(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\nimport {getDenseTexShape, PackingScheme} from './tex_util';\n\nexport class DecodeMatrixProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: [number, number, number];\n  packedInputs = false;\n  packedOutput = true;\n  outPackingScheme = PackingScheme.DENSE;\n\n  constructor(outputShape: [number, number, number]) {\n    const texShape = getDenseTexShape(outputShape);\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n\n    this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${\n        shader_util.getLogicalCoordinatesFromFlatIndex(\n            ['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\nimport {getDenseTexShape, PackingScheme} from './tex_util';\n\nexport class DecodeMatrixPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: [number, number, number];\n  outPackingScheme = PackingScheme.DENSE;\n\n  constructor(outputShape: [number, number, number]) {\n    const texShape = getDenseTexShape(outputShape);\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n\n    this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${\n        shader_util.getLogicalCoordinatesFromFlatIndex(\n            ['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthToSpaceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n  blockSize: number;\n  dataFormat: string;\n\n  constructor(\n      outputShape: number[], blockSize: number, dataFormat: 'NHWC'|'NCHW') {\n    this.outputShape = outputShape;\n    this.blockSize = blockSize;\n    this.dataFormat = dataFormat;\n    this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${blockSize};\n      int offset_h = imod(h, ${blockSize});\n      int in_w = w / ${blockSize};\n      int offset_w = imod(w, ${blockSize});\n      int offset_d = (offset_h * ${blockSize} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `;\n  }\n\n  private getHeightCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[1]`;\n    } else {\n      return `coords[2]`;\n    }\n  }\n\n  private getWidthCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[2]`;\n    } else {\n      return `coords[3]`;\n    }\n  }\n\n  private getDepthCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[3]`;\n    } else {\n      return `coords[1]`;\n    }\n  }\n\n  private getOutputDepthSize(): number {\n    if (this.dataFormat === 'NHWC') {\n      return this.outputShape[3];\n    } else {\n      return this.outputShape[1];\n    }\n  }\n\n  private getInputSamplingString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `getX(b, in_h, in_w, in_d)`;\n    } else {\n      return `getX(b, in_d, in_h, in_w)`;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DiagProgram implements GPGPUProgram {\n  variableNames = ['X'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(size: number) {\n    this.outputShape = [size, size];\n    this.userCode = `\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {ENCODE_FLOAT_SNIPPET} from './shader_compiler_util';\nimport {TextureUsage} from './tex_util';\n\nexport class EncodeFloatProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  outTexUsage = TextureUsage.DOWNLOAD;\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {ENCODE_FLOAT_SNIPPET} from './shader_compiler_util';\nimport {TextureUsage} from './tex_util';\n\nexport class EncodeFloatPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = true;\n  packedOutput = false;\n  outTexUsage = TextureUsage.DOWNLOAD;\n\n  constructor(outputShape: [number, number, number]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\nexport class EncodeMatrixProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(\n      outputShape: [number, number, number], texShape: [number, number],\n      inputIsUnsignedByte = false) {\n    const glsl = getGlslDifferences();\n    const [height, width] = texShape;\n    this.outputShape = outputShape;\n\n    let output = `result`;\n    if (inputIsUnsignedByte) {\n      output = `floor(result * 255. + 0.5)`;\n    }\n\n    this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${width};\n        int c = imod(flatIndex, ${width});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n        vec4 values = ${glsl.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${glsl.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\n/*\nThis is how the shader encodes a tensor with shape = [2, 3, 5]\n(indices are [batch, row, col]).\n\n000|001   002|003   004|xxx   020|021   022|023   024|xxx\n-------   -------   -------   -------   -------   -------\n010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\n100|101   102|103   104|xxx   120|121   122|123   124|xxx\n-------   -------   -------   -------   -------   -------\n110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\nSingle texels contain only values from the same batch, and from adjacent rows\nand columns.\n */\n\nexport class EncodeMatrixPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(\n      outputShape: [number, number, number], texShape: [number, number],\n      inputIsUnsignedByte = false) {\n    const glsl = getGlslDifferences();\n    const [height, width] = texShape;\n    this.outputShape = outputShape;\n\n    let mainLoop = '';\n    let output = 'result';\n    if (inputIsUnsignedByte) {\n      output = 'floor(result * 255. + 0.5)';\n    }\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        const channel = row * 2 + col;\n\n        mainLoop += `\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${outputShape[2]}) {\n            localCoords[2] += ${col};\n            if(localCoords[1] + ${row} < ${outputShape[1]}) {\n              localCoords[1] += ${row};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${width};\n              c = imod(flatIndex, ${width});\n              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n              values = ${glsl.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${channel}] = values[0];\n              } else if(offset == 1) {\n                result[${channel}] = values[1];\n              } else if(offset == 2) {\n                result[${channel}] = values[2];\n              } else {\n                result[${channel}] = values[3];\n              }\n            }\n          }\n        `;\n      }\n    }\n\n    this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${mainLoop}\n\n        ${glsl.output} = ${output};\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FillProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  valueLoc: WebGLUniformLocation;\n\n  constructor(shape: number[], value: number) {\n    this.variableNames = ['x'];\n    this.outputShape = shape;\n\n    this.userCode = `\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(value: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.valueLoc == null) {\n        this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n      }\n      gpgpu.gl.uniform1f(this.valueLoc, value);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class GatherProgram implements GPGPUProgram {\n  variableNames = ['A', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], indicesLength: number, axis: number) {\n    const outputShape: number[] = aShape.slice();\n    outputShape[axis] = indicesLength;\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(aShape, axis);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n  }\n}\n\nfunction getSourceCoords(aShape: number[], axis: number): string {\n  const rank = aShape.length;\n  if (rank > 4) {\n    throw Error(`Gather for rank ${rank} is not yet supported`);\n  }\n  if (rank === 1) {\n    return `int(getIndices(resRC))`;\n  }\n\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    if (i === axis) {\n      sourceCoords.push(`int(getIndices(${currentCoords[i]}))`);\n    } else {\n      sourceCoords.push(`${currentCoords[i]}`);\n    }\n  }\n  return sourceCoords.join();\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class GatherNDProgram implements GPGPUProgram {\n  variableNames = ['x', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  constructor(\n      private sliceDim: number, private strides: number[], shape: number[]) {\n    this.outputShape = shape;\n    const stridesType = getCoordsDataType(strides.length);\n    const dtype = getCoordsDataType(shape.length);\n    const strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';\n    this.userCode = `\n        ${stridesType} strides = ${stridesType}(${this.strides});\n         void main() {\n          ${dtype} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${strideString};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {PixelData, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {getGlslDifferences} from './glsl_version';\nimport * as tex_util from './tex_util';\nimport {TextureConfig} from './tex_util';\nimport * as webgl_util from './webgl_util';\n\nexport function createVertexShader(gl: WebGLRenderingContext): WebGLShader {\n  const glsl = getGlslDifferences();\n  const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n  return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\n\nexport function createVertexBuffer(gl: WebGLRenderingContext): WebGLBuffer {\n  // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n  const vertexArray = new Float32Array(\n      [-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n  return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\n\nexport function createIndexBuffer(gl: WebGLRenderingContext): WebGLBuffer {\n  // OpenGL (and WebGL) have \"CCW == front\" winding\n  const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n  return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\n\nfunction createAndConfigureTexture(\n    gl: WebGLRenderingContext, width: number, height: number,\n    internalFormat: number, textureFormat: number,\n    textureType: number): WebGLTexture {\n  webgl_util.validateTextureSize(width, height);\n  const texture = webgl_util.createTexture(gl);\n\n  const tex2d = gl.TEXTURE_2D;\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.texImage2D(\n          tex2d, 0, internalFormat, width, height, 0, textureFormat,\n          textureType, null));\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n  return texture;\n}\n\nexport function getInternalFormatForFloat32MatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatFloat;\n}\n\nexport function createFloat32MatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat32MatrixTexture(textureConfig),\n      textureConfig.textureFormatFloat, gl.FLOAT);\n}\n\nexport function getInternalFormatForFloat16MatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatHalfFloat;\n}\n\nexport function createFloat16MatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat16MatrixTexture(textureConfig),\n      textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\n\nexport function getInternalFormatForUnsignedBytesMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.downloadTextureFormat;\n}\n\nexport function createUnsignedBytesMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA,\n      gl.UNSIGNED_BYTE);\n}\n\nexport function getInternalFormatForPackedMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatPackedFloat;\n}\n\nexport function createPackedMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig),\n      gl.RGBA, gl.FLOAT);\n}\n\nexport function getInternalFormatForFloat16PackedMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatPackedHalfFloat;\n}\n\nexport function createFloat16PackedMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA,\n      textureConfig.textureTypeHalfFloat);\n}\n\nexport function bindVertexProgramAttributeStreams(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    vertexBuffer: WebGLBuffer): boolean {\n  const posOffset = 0;               // x is the first buffer element\n  const uvOffset = 3 * 4;            // uv comes after [x y z]\n  const stride = (3 * 4) + (2 * 4);  // xyz + uv, each entry is 4-byte float.\n  webgl_util.callAndCheck(\n      gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n  const success = webgl_util.bindVertexBufferToProgramAttribute(\n      gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n  return success &&\n      webgl_util.bindVertexBufferToProgramAttribute(\n          gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\n\nexport function uploadDenseMatrixToTexture(\n    gl: WebGLRenderingContext, texture: WebGLTexture, width: number,\n    height: number, data: TypedArray, textureConfig: TextureConfig) {\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n\n  let dataForUpload: TypedArray, texelDataType: number, internalFormat: number;\n  if (data instanceof Uint8Array) {\n    dataForUpload = new Uint8Array(width * height * 4);\n    texelDataType = gl.UNSIGNED_BYTE;\n    internalFormat = gl.RGBA;\n  } else {\n    dataForUpload = new Float32Array(width * height * 4);\n    texelDataType = gl.FLOAT;\n    internalFormat = textureConfig.internalFormatPackedFloat;\n  }\n\n  dataForUpload.set(data);\n\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.texImage2D(\n          gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA,\n          texelDataType, dataForUpload));\n\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function uploadPixelDataToTexture(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n    HTMLVideoElement) {\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n  if ((pixels as PixelData).data instanceof Uint8Array) {\n    webgl_util.callAndCheck(\n        gl,\n        () => gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA,\n            gl.UNSIGNED_BYTE, (pixels as PixelData).data));\n  } else {\n    webgl_util.callAndCheck(\n        gl,\n        () => gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,\n            pixels as ImageData | HTMLImageElement | HTMLCanvasElement |\n                HTMLVideoElement));\n  }\n\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function createBufferFromOutputTexture(\n    gl2: WebGL2RenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLBuffer {\n  // Create and bind the buffer.\n  const buffer = gl2.createBuffer();\n  webgl_util.callAndCheck(\n      gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n\n  // Initialize the buffer to the size of the texture in bytes.\n  const bytesPerFloat = 4;\n  const valuesPerTexel = 4;\n  const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n\n  webgl_util.callAndCheck(\n      gl2,\n      () => gl2.bufferData(\n          gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n\n  // Enqueue a command on the GPU command queue to copy of texture into the\n  // buffer.\n  webgl_util.callAndCheck(\n      gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n\n  webgl_util.callAndCheck(\n      gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n\n  return buffer;\n}\n\nexport function downloadFloat32MatrixFromBuffer(\n    gl: WebGLRenderingContext, buffer: WebGLBuffer,\n    size: number): Float32Array {\n  const gl2 = gl as WebGL2RenderingContext;\n\n  const downloadTarget = new Float32Array(size);\n\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n\n  return downloadTarget;\n}\n\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig) {\n  const [w, h] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n\n  const numChannels = 4;\n  const downloadTarget = new Uint8Array(\n      tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.readPixels(\n          0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE,\n          downloadTarget));\n\n  // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n  // decoding of the 4 bytes that back each 32 bit float.\n  return new Float32Array(downloadTarget.buffer);\n}\n\nexport function downloadPackedMatrixFromBuffer(\n    gl: WebGLRenderingContext, buffer: WebGLBuffer, batch: number, rows: number,\n    cols: number, physicalRows: number, physicalCols: number,\n    textureConfig: TextureConfig): Float32Array {\n  const gl2 = gl as WebGL2RenderingContext;\n\n  const downloadTarget =\n      new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(\n          physicalRows, physicalCols));\n\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n\n  return downloadTarget;\n}\n\nexport function downloadMatrixFromPackedOutputTexture(\n    gl: WebGLRenderingContext, physicalRows: number,\n    physicalCols: number): Float32Array {\n  const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.readPixels(\n          0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n\n  return packedRGBA;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, PixelData, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext, setWebGLContext} from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport {TextureConfig} from './tex_util';\nimport {WebGL1DisjointQueryTimerExtension, WebGL2DisjointQueryTimerExtension} from './webgl_types';\nimport * as webgl_util from './webgl_util';\n\nexport interface FenceContext {\n  query: WebGLQuery|WebGLSync;\n  isFencePassed(): boolean;\n}\n\nexport class GPGPUContext {\n  gl: WebGLRenderingContext;\n  textureFloatExtension: {};\n  textureHalfFloatExtension: {};\n  colorBufferFloatExtension: {};\n  colorBufferHalfFloatExtension: {};\n  disjointQueryTimerExtension: WebGL2DisjointQueryTimerExtension|\n      WebGL1DisjointQueryTimerExtension;\n  vertexBuffer: WebGLBuffer;\n  indexBuffer: WebGLBuffer;\n  framebuffer: WebGLFramebuffer;\n  outputTexture: WebGLTexture|null = null;\n  program: WebGLProgram|null = null;\n  private disposed = false;\n  private disjoint: boolean;\n  textureConfig: TextureConfig;\n\n  constructor(gl?: WebGLRenderingContext) {\n    const glVersion = env().getNumber('WEBGL_VERSION');\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    }\n    // WebGL 2.0 enables texture floats without an extension.\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n\n      this.textureFloatExtension =\n          webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support half float textures, yet the ' +\n            'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support color renderable half floats, yet ' +\n            'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n\n    this.textureConfig =\n        tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  private get debug(): boolean {\n    return env().getBool('DEBUG');\n  }\n\n  public dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.program != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n          ' This is probably a resource leak, delete the program with ' +\n          'GPGPUContext.deleteProgram before disposing.');\n    }\n    if (this.outputTexture != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound output matrix ' +\n          'texture.  This is probably a resource leak, delete the output ' +\n          'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n          'disposing.');\n    }\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(\n        gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  public createFloat32MatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createFloat16MatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createUnsignedBytesMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public uploadPixelDataToTexture(\n      texture: WebGLTexture,\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  public uploadDenseMatrixToTexture(\n      texture: WebGLTexture, width: number, height: number, data: TypedArray) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(\n        this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  public createFloat16PackedMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createPackedMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public deleteMatrixTexture(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  public downloadByteEncodedFloatMatrixFromOutputTexture(\n      texture: WebGLTexture, rows: number, columns: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(\n            this.gl, rows, columns, this.textureConfig));\n  }\n\n  public downloadPackedMatrixFromBuffer(\n      buffer: WebGLBuffer, batch: number, rows: number, columns: number,\n      physicalRows: number, physicalCols: number): Float32Array {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(\n        this.gl, buffer, batch, rows, columns, physicalRows, physicalCols,\n        this.textureConfig);\n  }\n\n  public downloadFloat32MatrixFromBuffer(buffer: WebGLBuffer, size: number):\n      Float32Array {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  public createBufferFromTexture(\n      texture: WebGLTexture, rows: number, columns: number): WebGLBuffer {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(\n        this.gl as WebGL2RenderingContext, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  public createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let query: WebGLQuery|WebGLSync;\n    let isFencePassed: () => boolean;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl as WebGL2RenderingContext;\n\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED ||\n            status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (\n        env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n      isFencePassed = () => this.isQueryAvailable(\n          query,\n          env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {query, isFencePassed};\n  }\n\n  public downloadMatrixFromPackedTexture(\n      texture: WebGLTexture, physicalRows: number,\n      physicalCols: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadMatrixFromPackedOutputTexture(\n            this.gl, physicalRows, physicalCols));\n  }\n\n  private vertexAttrsAreBound = false;\n\n  public createProgram(fragmentShaderSource: string): WebGLProgram {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    const fragmentShader: WebGLShader =\n        webgl_util.createFragmentShader(gl, fragmentShaderSource);\n    const vertexShader: WebGLShader = gpgpu_util.createVertexShader(gl);\n    const program: WebGLProgram = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program);\n    }\n    if (!this.vertexAttrsAreBound) {\n      this.setProgram(program);\n      this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(\n          gl, this.program, this.vertexBuffer);\n    }\n    return program;\n  }\n\n  public deleteProgram(program: WebGLProgram) {\n    this.throwIfDisposed();\n    if (program === this.program) {\n      this.program = null;\n    }\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n    }\n  }\n\n  public setProgram(program: WebGLProgram|null) {\n    this.throwIfDisposed();\n    this.program = program;\n    if ((this.program != null) && this.debug) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  public getUniformLocation(\n      program: WebGLProgram, uniformName: string,\n      shouldThrow = true): WebGLUniformLocation {\n    this.throwIfDisposed();\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(\n          this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(\n          this.gl, program, uniformName);\n    }\n  }\n\n  public getAttributeLocation(program: WebGLProgram, attribute: string):\n      number {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(\n        this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  public getUniformLocationNoThrow(program: WebGLProgram, uniformName: string):\n      WebGLUniformLocation {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  public setInputMatrixTexture(\n      inputMatrixTexture: WebGLTexture, uniformLocation: WebGLUniformLocation,\n      textureUnit: number) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(\n        this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  public setOutputMatrixTexture(\n      outputMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  public setOutputPackedMatrixTexture(\n      outputPackedMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.throwIfDisposed();\n    const [width, height] =\n        tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  public setOutputMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    this.setOutputMatrixWriteRegionDriver(\n        startColumn, startRow, numColumns, numRows);\n  }\n\n  public setOutputPackedMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  public debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  public executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n    if (this.debug) {\n      this.debugValidate();\n    }\n    webgl_util.callAndCheck(\n        gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  public blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  private getQueryTimerExtension(): WebGL1DisjointQueryTimerExtension\n      |WebGL2DisjointQueryTimerExtension {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension =\n          webgl_util.getExtensionOrThrow(\n              this.gl,\n              env().getNumber(\n                  'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                  'EXT_disjoint_timer_query_webgl2' :\n                  'EXT_disjoint_timer_query') as\n              WebGL1DisjointQueryTimerExtension |\n          WebGL2DisjointQueryTimerExtension;\n    }\n    return this.disjointQueryTimerExtension;\n  }\n\n  private getQueryTimerExtensionWebGL2(): WebGL2DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension();\n  }\n\n  private getQueryTimerExtensionWebGL1(): WebGL1DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension() as WebGL1DisjointQueryTimerExtension;\n  }\n\n  beginQuery(): WebGLQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT() as WebGLQuery;\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  public async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await util.repeatedTry(\n        () => this.disposed ||  // while testing contexts are created / disposed\n                                // in rapid succession, so without this check we\n                                // may poll for the query timer indefinitely\n            this.isQueryAvailable(\n                query,\n                env().getNumber(\n                    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(\n        query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  private getQueryTime(query: WebGLQuery, queryTimerVersion: number): number {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const timeElapsedNanos =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  private isQueryAvailable(query: WebGLQuery, queryTimerVersion: number):\n      boolean {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const available =\n          gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const available =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    util.repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n\n  private bindTextureToFrameBuffer(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(\n        this.gl, texture, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  private unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(\n          this.gl, this.outputTexture, this.framebuffer);\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  private downloadMatrixDriver(\n      texture: WebGLTexture,\n      downloadAndDecode: () => Float32Array): Float32Array {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n\n    return result;\n  }\n\n  private setOutputMatrixTextureDriver(\n      outputMatrixTextureMaybePacked: WebGLTexture, width: number,\n      height: number) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(\n        gl, outputMatrixTextureMaybePacked, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  private setOutputMatrixWriteRegionDriver(\n      x: number, y: number, width: number, height: number) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(\n        this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  private throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  private throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean,\n  resolveFn: () => void\n};\n\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, Tensor, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport * as shader_compiler from './shader_compiler';\nimport {InputInfo, ShapeInfo} from './shader_compiler';\nimport {PackingScheme, TextureData, TextureUsage} from './tex_util';\n\nexport interface GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  /** If true, this program expects packed input textures. Defaults to false. */\n  packedInputs?: boolean;\n  /** If true, this program produces a packed texture. Defaults to false. */\n  packedOutput?: boolean;\n  /**\n   * Affects what type of texture we allocate for the output. Defaults to\n   * `TextureUsage.RENDER`.\n   */\n  outTexUsage?: TextureUsage;\n  /**\n   * The type of scheme to use when packing texels for the output values.\n   * See `PackingScheme` for details. Defaults to `PackingScheme.SHARED_BATCH`.\n   */\n  outPackingScheme?: PackingScheme;\n}\n\nexport interface GPGPUBinary {\n  webGLProgram: WebGLProgram;\n  program: GPGPUProgram;\n  uniformLocations: {[name: string]: WebGLUniformLocation};\n  source: string;\n  inShapeInfos: ShapeInfo[];\n  outShapeInfo: ShapeInfo;\n  infLoc: WebGLUniformLocation;\n  nanLoc: WebGLUniformLocation;\n}\n\nexport interface TensorData {\n  shape: number[];\n  texData: TextureData;\n  isUniform: boolean;\n  // Available when we decide to upload as uniform instead of texture.\n  uniformValues?: TypedArray;\n}\n\nexport function compileProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, program: GPGPUProgram, inputs: TensorData[],\n    output: TensorData): GPGPUBinary {\n  const userCode = program.userCode;\n  const inputInfos: InputInfo[] = inputs.map((input, i) => {\n    const shapeInfo: ShapeInfo = {\n      logicalShape: input.shape,\n      texShape: input.isUniform ? null : input.texData.texShape,\n      isUniform: input.isUniform,\n      isPacked: input.isUniform ? false : input.texData.isPacked,\n      flatOffset: null\n    };\n    if (input.texData != null && input.texData.slice != null &&\n        input.texData.slice.flatOffset > 0) {\n      shapeInfo.flatOffset = input.texData.slice.flatOffset;\n    }\n    return {name: program.variableNames[i], shapeInfo};\n  });\n  const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n  const outShapeInfo: ShapeInfo = {\n    logicalShape: output.shape,\n    texShape: output.texData.texShape,\n    isUniform: false,\n    isPacked: output.texData.isPacked,\n    flatOffset: null\n  };\n  const source = shader_compiler.makeShader(\n      inputInfos, outShapeInfo, userCode, program.packedInputs);\n\n  const webGLProgram = gpgpu.createProgram(source);\n\n  // Add special uniforms (NAN, INFINITY)\n  let infLoc: WebGLUniformLocation = null;\n  const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n  }\n\n  // Add user-defined uniforms\n  const uniformLocations: {[name: string]: WebGLUniformLocation} = {};\n  for (let i = 0; i < program.variableNames.length; i++) {\n    const varName = program.variableNames[i];\n    const shouldThrow = false;\n    uniformLocations[varName] =\n        gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n    uniformLocations[`offset${varName}`] =\n        gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n  }\n\n  return {\n    program,\n    source,\n    webGLProgram,\n    uniformLocations,\n    inShapeInfos,\n    outShapeInfo,\n    infLoc,\n    nanLoc,\n  };\n}\n\nfunction validateBinaryAndProgram(\n    shapeInfos: ShapeInfo[], inputs: TensorData[]) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(\n        `Binary was compiled with ${shapeInfos.length} inputs, but ` +\n        `was executed with ${inputs.length} inputs`);\n  }\n\n  shapeInfos.forEach((s, i) => {\n    const shapeA = s.logicalShape;\n    const input = inputs[i];\n    const shapeB = input.shape;\n\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(\n          `Binary was compiled with different shapes than ` +\n          `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n    }\n    // The input is uploaded as uniform.\n    if (s.isUniform && input.isUniform) {\n      return;\n    }\n\n    const texShapeA = s.texShape;\n    const texShapeB = input.isUniform ? null : input.texData.texShape;\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(\n          `Binary was compiled with different texture shapes than the` +\n          ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n    }\n  });\n}\n\nexport function runProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, binary: GPGPUBinary, inputs: TensorData[],\n    output: TensorData,\n    customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) =>\n        void): void {\n  validateBinaryAndProgram(binary.inShapeInfos, inputs);\n  validateBinaryAndProgram([binary.outShapeInfo], [output]);\n\n  const outTex = output.texData.texture;\n  const outTexShape = output.texData.texShape;\n  if (output.texData.isPacked) {\n    gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  } else {\n    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  }\n  gpgpu.setProgram(binary.webGLProgram);\n\n  // Set special uniforms (NAN, INFINITY)\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    if (binary.infLoc !== null) {\n      gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n    }\n  }\n  if (binary.nanLoc !== null) {\n    gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n  }\n\n  // Set user-defined inputs\n  inputs.forEach((input, i) => {\n    const varName = binary.program.variableNames[i];\n    const varLoc = binary.uniformLocations[varName];\n    const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n\n    if (varLoc == null) {\n      // The compiler inferred that this variable is not used in this shader.\n      return;\n    }\n\n    if (input.isUniform) {\n      // Upload the values of the tensor as uniform.\n      if (util.sizeFromShape(input.shape) < 2) {\n        gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n      } else {\n        let vals = input.uniformValues;\n        if (!(vals instanceof Float32Array)) {\n          vals = new Float32Array(vals);\n        }\n        gpgpu.gl.uniform1fv(varLoc, vals);\n      }\n      return;\n    }\n\n    // If the input was sliced, upload the flat offset index.\n    if (input.texData.slice != null && varOffsetLoc != null) {\n      gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n    }\n\n    gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n  });\n\n  if (customSetup != null) {\n    customSetup(gpgpu, binary.webGLProgram);\n  }\n  gpgpu.executeProgram();\n}\n\nexport function makeShaderKey(\n    program: GPGPUProgram, inputs: TensorData[], output: TensorData): string {\n  let keyInputs = '';\n  inputs.concat(output).forEach(x => {\n    const hasOffset = x.texData != null && x.texData.slice != null &&\n        x.texData.slice.flatOffset > 0;\n    const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n    keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n  });\n  const keyUserCode = program.userCode;\n  let key = program.constructor.name;\n  // Fast string concat. See https://jsperf.com/string-concatenation/14.\n  key += '_' + keyInputs + '_' + keyUserCode;\n  return key;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Im2ColPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      outputShape: number[], inputShape: number[],\n      convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = outputShape;\n\n    const {\n      filterWidth,\n      inChannels,\n      strideWidth,\n      strideHeight,\n      padInfo,\n      outWidth,\n      dilationWidth,\n      dilationHeight,\n      dataFormat\n    } = convInfo;\n    const {left, top} = padInfo;\n    const itemsPerBlockRow = inChannels * filterWidth;\n    const glsl = getGlslDifferences();\n    const isChannelsLast = dataFormat === 'channelsLast';\n    const rowDim = isChannelsLast ? 0 : 1;\n    const colDim = isChannelsLast ? 1 : 2;\n\n    let unrolled = ``;\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        unrolled += `\n          blockIndex = rc.y + ${col};\n          pos = rc.x + ${row};\n\n          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {\n            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${\n            top};\n            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});\n\n            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${\n            strideWidth}. - ${left}.);\n              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${\n            itemsPerBlockRow}.) / ${inChannels}.));\n\n              if(d1 < ${inputShape[colDim]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${inChannels}.));\n\n                if (${isChannelsLast}) {\n                  innerDims = vec2(d1, ch);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;\n      }\n    }\n\n    this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${unrolled}\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      xShape: number[], radius: number, bias: number, alpha: number,\n      beta: number) {\n    const rad = radius;\n    const maxD = xShape[3] - 1;\n    this.outputShape = xShape;\n\n    // optimize pow(bias + alpha * sum, -beta)\n    // src: https://github.com/tensorflow/tensorflow/..\n    // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n    // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n    let powOperator;\n    const basis = `float(${bias}) + float(${alpha}) * sum`;\n    if (beta === 0.5) {\n      powOperator = `inversesqrt(${basis})`;\n    } else if (beta === 1.0) {\n      powOperator = `1.0/(${basis})`;\n    } else {\n      powOperator = `exp(log(${basis}) * float(-${beta}));`;\n    }\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${rad}; j <= ${rad}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${maxD}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${powOperator};\n        setOutput(val);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNGradProgram implements GPGPUProgram {\n  variableNames = ['inputImage', 'outputImage', 'dy'];\n  outputShape: number[] = [];\n  userCode: string;\n  depthRadius: number;\n  bias: number;\n  alpha: number;\n  beta: number;\n  depth: number;\n\n  constructor(\n      inputShape: number[], depthRadius: number, bias: number, alpha: number,\n      beta: number) {\n    this.outputShape = inputShape;\n    this.depth = inputShape[3];\n    this.depthRadius = depthRadius;\n    this.bias = bias;\n    this.alpha = alpha;\n    this.beta = beta;\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${depthRadius})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${depthRadius} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${alpha}) * norm + float(${bias});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${alpha})\n                * float(${beta})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${beta});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      xShape: number[], radius: number, bias: number, alpha: number,\n      beta: number) {\n    const rad = radius;\n    const maxD = xShape[3] - 1;\n    this.outputShape = xShape;\n\n    // optimize pow(bias + alpha * sum, -beta)\n    // src: https://github.com/tensorflow/tensorflow/..\n    // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n    // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n    let powOperator;\n    const basis = `float(${bias}) + float(${alpha}) * sum`;\n    if (beta === 0.5) {\n      powOperator = `inversesqrt(${basis})`;\n    } else if (beta === 1.0) {\n      powOperator = `1.0/(${basis})`;\n    } else {\n      powOperator = `exp(log(${basis}) * float(-${beta}));`;\n    }\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${rad};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${rad}; j <= ${rad}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${powOperator};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MaxPool2DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy', 'maxPos'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n          wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${effectiveFilterWidth} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class MaxPool3DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy', 'maxPos'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const lastIndex =\n        effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n           wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${lastIndex} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                  wR * ${effectiveFilterWidth} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MatMulPackedProgram implements GPGPUProgram {\n  variableNames = ['matrixA', 'matrixB'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      aShape: [number, number, number], bShape: [number, number, number],\n      outputShape: [number, number, number], transposeA = false,\n      transposeB = false, addBias = false, activation: string = null,\n      hasPreluActivation = false) {\n    this.outputShape = outputShape;\n\n    const sharedDim = transposeA ? aShape[1] : aShape[2];\n    const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n\n    const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n    const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n    const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n    const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    let batchASnippet = 'rc.x';\n    let batchBSnippet = 'rc.x';\n    if (aShape[0] < bShape[0]) {\n      batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;\n    } else if (bShape[0] < aShape[0]) {\n      batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          int batchA = ${batchASnippet};\n          int batchB = ${batchBSnippet};\n          vec4 a = getMatrixA(batchA, ${aSample});\n          vec4 b = getMatrixB(batchB, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MultinomialProgram implements GPGPUProgram {\n  variableNames = ['probs'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  seedLoc: WebGLUniformLocation;\n\n  constructor(batchSize: number, numOutcomes: number, numSamples: number) {\n    this.outputShape = [batchSize, numSamples];\n\n    this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${numOutcomes - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${numOutcomes - 1}));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(seed: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.seedLoc == null) {\n        this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n      }\n      gpgpu.gl.uniform1f(this.seedLoc, seed);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class OneHotProgram implements GPGPUProgram {\n  variableNames = ['indices'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  seedLoc: WebGLUniformLocation;\n\n  constructor(\n      numIndices: number, depth: number, onValue: number, offValue: number) {\n    this.outputShape = [numIndices, depth];\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${offValue}), float(${onValue}),\n                      float(index == coords.y)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PackProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(\n      outputShape:\n          number[]) {  // TODO(https://github.com/tensorflow/tfjs/issues/893):\n                       // Only input / output 3D tensors.\n    this.outputShape = outputShape;\n    const rank = outputShape.length;\n\n    if (rank === 0) {\n      this.userCode = `\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;\n    } else {\n      const channels = getChannels('rc', rank);\n      const dtype = getCoordsDataType(rank);\n      const outOfBoundsCondition =\n          getOutOfBoundsCondition(rank, outputShape, channels);\n      const setup = getSetup(\n          rank, outputShape[outputShape.length - 1],\n          outputShape[outputShape.length - 2], channels);\n      const output = getOutput(outputShape, channels);\n\n      this.userCode = `\n        void main() {\n          ${dtype} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            setOutput(vec4(0));\n          } else {\n            ${setup}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `;\n    }\n  }\n}\n\nfunction getSourceCoordsArr(rank: number, dims: string[]): string[] {\n  const coords = [];\n\n  for (let row = 0; row <= 1; row++) {\n    for (let col = 0; col <= 1; col++) {\n      let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;\n\n      for (let d = 2; d < rank; d++) {\n        coord = `${dims[dims.length - 1 - d]},` + coord;\n      }\n\n      coords.push(coord);\n    }\n  }\n  return coords;\n}\n\nfunction getOutOfBoundsCondition(\n    rank: number, shape: number[], dims: string[]): string {\n  if (rank === 1) {\n    return `rc > ${shape[0]}`;\n  }\n\n  let cond = '';\n  for (let i = rank - 2; i < rank; i++) {\n    cond += `${dims[i]} >= ${shape[i]}`;\n    if (i < rank - 1) {\n      cond += '||';\n    }\n  }\n\n  return cond;\n}\n\nfunction getSetup(\n    rank: number, cols: number, rows: number, dims: string[]): string {\n  if (rank === 1) {\n    return '';\n  }\n\n  const innerDims = dims.slice(-2);\n\n  return `\n    int r = ${innerDims[0]};\n    int c = ${innerDims[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${cols};\n    bool rEdge = rp1 >= ${rows};\n  `;\n}\n\nfunction getOutput(shape: number[], dims: string[]): string {\n  const rank = shape.length;\n  const sourceCoords = getSourceCoordsArr(rank, dims);\n  if (rank === 1) {\n    return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  }\n\n  return `getA(${sourceCoords[0]}),\n          cEdge ? 0. : getA(${sourceCoords[1]}),\n          rEdge ? 0. : getA(${sourceCoords[2]}),\n          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PadProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      constantValue: number) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const type = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const unpackedCoords =\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n\n    if (rank === 1) {\n      this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${constantValue}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;\n      return;\n    }\n    this.userCode = `\n      ${type} start = ${type}(${start});\n      ${type} end = ${type}(${end});\n\n      void main() {\n        ${type} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${constantValue}));\n        } else {\n          ${type} coords = outC - start;\n          setOutput(getX(${unpackedCoords}));\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PadPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      constantValue: number) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const coords = getChannels('rc', rank);\n    const source = getChannels('source', rank);\n    const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n    const innerDims =\n        rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n\n    const componentSetup = [\n      `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;\n       if(${cLimit}) {\n      `,\n      rank === 1 ? '' : `}\n       rc = outputLoc;\n       ${coords[rank - 2]} += 1;\n       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,\n      rank === 1 ? '' : `  ${coords[rank - 1]} += 1;\n         if(${cLimit}) {`\n    ];\n\n    const paddingArea = rank === 1 ?\n        'rc < start || rc >= end' :\n        'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n    let mainLoop = '';\n    for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n      mainLoop += `\n        ${componentSetup[i]}\n        if (${paddingArea}) {\n          result[${i}] = float(${constantValue});\n        } else {\n          ${dtype} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n    }\n    mainLoop += (rank === 1 ? `} ` : `}}`);\n\n    this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Pool2DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n    const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${\n        convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n    const flattenPositionStr =\n        `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${\n          flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                                                    flattenPositionStr) :\n                             `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n\nexport class Pool3DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv3DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${\n          flattenPositions ?\n              (includeBatchInIndex ?\n                   `(((batch * ${convInfo.inDepth} + xD) * ${\n                       convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${\n                       convInfo.inChannels} + ch` :\n                   `((xD * ${convInfo.inHeight} + xR) * ${\n                       convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n              `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ReduceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo,\n      reduceType: 'all'|'any'|'max'|'min'|'sum'|'prod') {\n    const {windowSize, batchSize, inSize, outSize} = reduceInfo;\n    this.outputShape = [batchSize, outSize];\n\n    let initializationValue = '0.0';\n    let compareOp = ``;\n\n    if (reduceType === 'prod') {\n      initializationValue = '1.0';\n    } else if (reduceType === 'min') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '1.0 / 1e-20';\n      compareOp = `min`;\n    } else if (reduceType === 'max') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n      compareOp = `max`;\n    }\n\n    let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (reduceType === 'sum') {\n      returnValue = `sumValue`;\n    } else if (reduceType === 'prod') {\n      returnValue = `prodValue`;\n    } else if (reduceType === 'all') {\n      returnValue = `allValue`;\n    } else if (reduceType === 'any') {\n      returnValue = `anyValue`;\n    }\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    let vecType = `vec4`;\n\n    if (reduceType === 'all') {\n      initializationValue = '1.0';\n      updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    } else if (reduceType === 'any') {\n      initializationValue = '0.0';\n      updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    }\n\n    let checkOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\nexport class ReshapePackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(outputShape: [number, number, number], inputShape: [\n    number, number, number\n  ]) {\n    this.outputShape = outputShape;\n\n    let mainLoop = ``;\n    for (let i = 0; i < 4; i++) {\n      let thisRC = `thisRC = rc;`;\n      if (i % 2 === 1) {\n        thisRC += `thisRC.z += 1;`;\n      }\n      if (i > 1) {\n        thisRC += `thisRC.y += 1;`;\n      }\n\n      mainLoop += `\n        ${thisRC}\n        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i > 0 ? '}' : ''}\n      `;\n    }\n\n    this.userCode = `\n      ${getReshapedInputCoords(inputShape)}\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${outputShape[1]};\n        int cols = ${outputShape[2]};\n\n        ${mainLoop}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n\nfunction getReshapedInputCoords(shape: [number, number, number]): string {\n  const coordsFromIndexSnippet =\n      shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor4D} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(dy: Tensor4D, x: Tensor4D, alignCorners: boolean) {\n    this.outputShape = x.shape;\n    const [, xHeight, xWidth, ] = x.shape;\n    const [, yHeight, yWidth] = dy.shape;\n\n    // In the backwards pass, we want to find the pixels that were generated for\n    // each pixel in the input image the forward pass and add the corresponding\n    // coefficient from dy to the gradient (with some interpolation).\n\n    const effectiveXSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n      (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n\n    const effectiveYSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n      (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor4D} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeigborBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(dy: Tensor4D, x: Tensor4D, alignCorners: boolean) {\n    this.outputShape = x.shape;\n    const [, xHeight, xWidth, ] = x.shape;\n    const [, yHeight, yWidth] = dy.shape;\n\n    // In the backwards pass, we want to find the pixels that were generated for\n    // each pixel in the input image the forward pass and add the corresponding\n    // coefficient from dy to the gradient (with some interpolation).\n\n    const effectiveXSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n      (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n\n    const effectiveYSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n      (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${effectiveXSize[0]}) *\n                (float(dyR) / float(${effectiveYSize[0]}));\n\n            float sourceFracCol =\n                float(${effectiveXSize[1]}) *\n                  (float(dyC) / float(${effectiveYSize[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${xHeight}) - 1),\n                ${alignCorners} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${xWidth}) - 1),\n                ${alignCorners} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeighborProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    // When align corners is false, we rounds the value with floor.\n    const roundBase = alignCorners ? '0.5' : '0.0';\n\n    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReverseProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n\n    if (rank === 1) {\n      this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${xShape[0]} - coord - 1));\n        }\n      `;\n      return;\n    }\n    const getInCoord = (i: number) => {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - coords[${i}] - 1`;\n      }\n      return `coords[${i}]`;\n    };\n    const inCoords = xShape.map((_, i) => getInCoord(i)).join(',');\n    const type = getCoordsDataType(rank);\n\n    this.userCode = `\n      void main() {\n        ${type} coords = getOutputCoords();\n        setOutput(getX(${inCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReversePackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn =\n        `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n\n    function getR(channels: string[]): string {\n      return getChannel(channels);\n    }\n\n    function getG(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getB(channels: string[]): string {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getA(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getChannel(channels: string[]): string {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n\n    function getInCoord(i: number, channels1: string[]): string {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ScatterProgram implements GPGPUProgram {\n  variableNames = ['updates', 'indices', 'defaultValue'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      updateSize: number, sliceDim: number, indicesRank: number,\n      updatesRank: number, strides: number[], shape: number[],\n      summingDupeIndex = true) {\n    this.outputShape = shape;\n    const stridesType = getCoordsDataType(strides.length);\n    const dtype = getCoordsDataType(shape.length);\n    let indicesString = '';\n    if (indicesRank === 1) {\n      indicesString = 'i';\n    } else if (indicesRank === 2) {\n      indicesString = 'i, j';\n    }\n    const indicesSnippet = `getIndices(${indicesString})`;\n\n    let updatesString = '';\n    if (updatesRank === 1) {\n      updatesString = 'i';\n    } else if (updatesRank === 2) {\n      updatesString = 'i, coords[1]';\n    }\n    const updatesSnippet = `getUpdates(${updatesString})`;\n\n    const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';\n    this.userCode = `\n        ${stridesType} strides = ${stridesType}(${strides});\n\n        void main() {\n          ${dtype} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${updateSize}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${sliceDim}; j++) {\n              int index = round(${indicesSnippet});\n              flattenedIndex += index * ${strideString};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${updatesSnippet};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class SegmentOpProgram implements GPGPUProgram {\n  variableNames = ['x', 'segmentIds'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      segOpInfo: backend_util.segment_util.SegOpInfo,\n      segOpType: 'unsortedSegmentSum') {\n    const windowSize = segOpInfo.windowSize;\n    const batchSize = segOpInfo.batchSize;\n    const inSize = segOpInfo.inSize;\n    const numSegments = segOpInfo.numSegments;\n    const outSize = numSegments * Math.ceil(inSize / windowSize);\n    this.outputShape = [batchSize, outSize];\n\n    const initializationValue = '0.0';\n    const returnValue = `sumValue`;\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n\n    let checkValueOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n\n    let checkSegmentIdOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SelectProgram implements GPGPUProgram {\n  variableNames = ['c', 'a', 'b'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(cRank: number, shape: number[], rank: number) {\n    this.outputShape = shape;\n\n    let cCoords;\n    let abCoords;\n    if (rank > 4) {\n      throw Error(`Where for rank ${rank} is not yet supported`);\n    }\n\n    if (rank === 1) {\n      abCoords = `resRC`;\n      cCoords = `resRC`;\n    } else {\n      const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n      const cCoordVars = [];\n      const abCoordVars = [];\n      for (let i = 0; i < shape.length; i++) {\n        abCoordVars.push(`${currentCoords[i]}`);\n        if (i < cRank) {\n          cCoordVars.push(`${currentCoords[i]}`);\n        }\n      }\n      cCoords = cCoordVars.join();\n      abCoords = abCoordVars.join();\n    }\n\n    const dtype = getCoordsDataType(rank);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        float cVal = getC(${cCoords});\n        if (cVal >= 1.0) {\n          setOutput(getA(${abCoords}));\n        } else {\n          setOutput(getB(${abCoords}));\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SliceProgram implements GPGPUProgram {\n  variableNames = ['source'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  // Caching uniform location for speed.\n  startLoc: WebGLUniformLocation;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n\n    const dtype = getCoordsDataType(this.rank);\n    const uniformPart = `uniform int start[${this.rank}];`;\n    const sourceCoords = getCoords(this.rank);\n\n    let body: string;\n    const coordSum = destSize.map((_, i) => {\n      return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n    });\n    body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n    this.userCode = `\n      ${uniformPart}\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(start: number[]) {\n    if (start.length !== this.rank) {\n      throw Error(\n          `The rank (${this.rank}) of the program must match the ` +\n          `length of start (${start.length})`);\n    }\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.startLoc == null) {\n        this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n        if (this.startLoc == null) {\n          // This means the compiler has optimized and realized it doesn't need\n          // the uniform.\n          return;\n        }\n      }\n      gpgpu.gl.uniform1iv(this.startLoc, start);\n    };\n  }\n}\n\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\n\nfunction getCoords(rank: number): string {\n  if (rank === 1) {\n    return 'sourceLoc';\n  } else if (rank <= 6) {\n    return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n  } else {\n    throw Error(`Slicing for rank ${rank} is not yet supported`);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SlicePackedProgram implements GPGPUProgram {\n  variableNames = ['source'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  // Caching uniform location for speed.\n  startLoc: WebGLUniformLocation;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n\n    const dtype = getCoordsDataType(this.rank);\n    const coords = getChannels('coords', this.rank);\n    const sourceLoc = getChannels('sourceLoc', this.rank);\n\n    const innerDims =\n        this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;\n    const getChannel =\n        `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;\n    const upperRow = `\n      result.x = ${getChannel};\n      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n        ++${sourceLoc[this.rank - 1]};\n        result.y = ${getChannel};\n        --${sourceLoc[this.rank - 1]};\n      }\n    `;\n    const lowerRow = this.rank === 1 ? '' : `\n      --${coords[this.rank - 1]};\n      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {\n        ++${sourceLoc[this.rank - 2]};\n        result.z = ${getChannel};\n        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n          ++${sourceLoc[this.rank - 1]};\n          result.w = ${getChannel};\n        }\n      }\n    `;\n\n    const sourceLocSetup = this.rank <= 4 ?\n        `sourceLoc = coords +\n            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` :\n        destSize.map((_, i) => `${sourceLoc[i]} = ${coords[i]} + start[${i}];`)\n            .join('\\n');\n    this.userCode = `\n      uniform int start[${this.rank}];\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        ${dtype} sourceLoc;\n        ${sourceLocSetup}\n        vec4 result = vec4(0.);\n        ${upperRow}\n        ${lowerRow}\n        setOutput(result);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(start: number[]) {\n    if (start.length !== this.rank) {\n      throw Error(\n          `The rank (${this.rank}) of the program must match the ` +\n          `length of start (${start.length})`);\n    }\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.startLoc == null) {\n        this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n        if (this.startLoc == null) {\n          // This means the compiler has optimized and realized it doesn't need\n          // the uniform.\n          return;\n        }\n      }\n      gpgpu.gl.uniform1iv(this.startLoc, start);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class StridedSliceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(begin: number[], strides: number[], size: number[]) {\n    this.outputShape = size;\n    const rank = size.length;\n    const inputDtype = getCoordsDataType(size.length);\n    const dtype = getCoordsDataType(size.length);\n\n    let newCoords = '';\n    if (rank === 1) {\n      newCoords = 'coords * strides + begin';\n    } else {\n      let outputAxis = 0;\n      newCoords =\n          size.map((_, i) => {\n                outputAxis++;\n                return size.length === 1 ?\n                    `coords * strides[${i}] + begin[${i}]` :\n                    `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;\n              })\n              .join(',');\n    }\n\n    this.userCode = `\n      ${inputDtype} begin = ${inputDtype}(${begin});\n      ${inputDtype} strides = ${inputDtype}(${strides});\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        setOutput(getX(${newCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture} from './gpgpu_util';\nimport {getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureConfig, TextureUsage} from './tex_util';\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private _numBytesAllocated = 0;\n  private _numBytesFree = 0;  // How many bytes that have been allocated\n                              // are available for reuse.\n  private freeTextures: {[shape: string]: WebGLTexture[]} = {};\n  private logEnabled = false;\n  private usedTextures: {[shape: string]: WebGLTexture[]} = {};\n\n  constructor(private gpgpu: GPGPUContext) {}\n\n  acquireTexture(\n      shapeRC: [number, number], usage: TextureUsage,\n      isPacked: boolean): WebGLTexture {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture: WebGLTexture;\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture =\n          this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (\n        physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture =\n          this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.usedTextures[shapeKey].push(newTexture);\n\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n\n    return newTexture;\n  }\n\n  releaseTexture(\n      texture: WebGLTexture, shape: [number, number],\n      logicalTexType: TextureUsage, isPacked: boolean): void {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    const physicalTexType =\n        getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n    if (deleteTexThreshold !== -1 &&\n        this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n    if (texIndex < 0) {\n      throw new Error(\n          'Cannot release a texture that was never provided by this ' +\n          'texture manager');\n    }\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  private log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log(\n        'Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`,\n        `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${\n        Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated(): number {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree(): number {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n}\n\nfunction numBytesForInternalFormat(\n    gl: WebGLRenderingContext, internalFormat: number): number {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  }\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(\n    shape: [number, number], physicalTexType: PhysicalTextureType,\n    gl: WebGLRenderingContext, textureConfig: TextureConfig,\n    isPacked: boolean): number {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat =\n      internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n\n  let numElements: number;\n  if (isPacked) {\n    const [packedWidth, packedHeight] =\n        getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n\n  } else {\n    const [width, height] =\n        getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(\n    physicalTexType: PhysicalTextureType,\n    textureConfig: TextureConfig): number {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked: boolean):\n    PhysicalTextureType {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(\n    logicalTexType: TextureUsage, isPacked: boolean): PhysicalTextureType {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (\n      logicalTexType === TextureUsage.DOWNLOAD ||\n      logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(\n    shapeRowsCol: [number, number], physicalTexType: PhysicalTextureType,\n    isPacked: boolean): string {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TileProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], reps: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[i] * reps[i];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(aShape);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n  }\n}\n\nfunction getSourceCoords(aShape: number[]): string {\n  const rank = aShape.length;\n  if (rank > 5) {\n    throw Error(`Tile for rank ${rank} is not yet supported`);\n  }\n  if (rank === 1) {\n    return `imod(resRC, ${aShape[0]})`;\n  }\n\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];\n\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);\n  }\n  return sourceCoords.join();\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class UnaryOpProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(aShape: number[], opSnippet: string) {\n    this.outputShape = aShape;\n    this.userCode = `\n      float unaryOperation(float x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n\nconst CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;\n\nexport const LINEAR = `return x;`;\n\nexport const ABS = `return abs(x);`;\n\nexport const RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\n\nexport const RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\n\nexport const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\n\nexport const SELU = `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${backend_util.SELU_SCALEALPHA};\n  float scale = ${backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;\n\nexport function STEP(alpha = 0.0) {\n  return CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${alpha});\n  `;\n}\n\nexport const NEG = `return -x;`;\n\nexport const CEIL = `return ceil(x);`;\n\nexport const FLOOR = `return floor(x);`;\n\nexport const SIGN = `\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`;\n\nexport const IS_NAN = `return float(isnan(x));`;\n\nexport const IS_INF = `return float(isinf(x));`;\n\nexport const IS_FINITE = `return float(!isnan(x) && !isinf(x));`;\n\nexport const ROUND = `\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`;\n\nexport const EXP = `return exp(x);`;\n\nexport const EXPM1 = `return exp(x) - 1.0;`;\n\nexport const LOG = `if (x < 0.0) return NAN;\n  return log(x);`;\n\nexport const LOG1P = `return log(1.0 + x);`;\n\nexport const SQRT = `return sqrt(x);`;\n\nexport const RSQRT = `return inversesqrt(x);`;\n\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n\n/**\n * mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX\n *\n * epsilon is the difference between 1.0 and the next representable\n * float. For a single precision 32 bit float this should be 2^-23, see:\n * https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm\n *\n * too_large = (x > -threshold) is value above which exp(x) may overflow\n * but softplus(x) == x is within machine epsilon\n *\n * too_small = (x < threshold) is value below which exp(x) may underflow,\n * but softplus(x) == exp(x) is within machine epsilon.\n */\nexport const SOFTPLUS = `\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`;\n\nexport const ASIN = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`;\n\nexport const ACOS = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`;\n\nexport const ATAN = CHECK_NAN_SNIPPET + `\n  return atan(x);\n`;\n\nexport const SINH = `\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;\n\nexport const COSH = `\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;\n\nexport const TANH = `\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;\n\nexport const ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;\n\nexport const ACOSH = CHECK_NAN_SNIPPET + `\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));`;\n\nexport const ATANH = CHECK_NAN_SNIPPET + `\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;\n\nexport const ERF = `\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = ${backend_util.ERF_P};\n  float a1 = ${backend_util.ERF_A1};\n  float a2 = ${backend_util.ERF_A2};\n  float a3 = ${backend_util.ERF_A3};\n  float a4 = ${backend_util.ERF_A4};\n  float a5 = ${backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;\n\nexport const RECIPROCAL = `return 1.0 / x;`;\n\nexport const LOGICAL_NOT = `return float(!(x >= 1.0));`;\n\nexport const CLONE = 'return x;';\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport const LINEAR = `return x;`;\n\nexport const LOG = `\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n`;\n\nexport const RELU = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const RELU6 = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const ELU = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\n\nexport class UnaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(aShape: number[], opSnippet: string) {\n    this.outputShape = aShape;\n    this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels, getSourceCoords} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class UnpackProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = false;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(outputShape: number[]) {\n    this.outputShape = outputShape;\n    const rank = outputShape.length;\n\n    const channels = getChannels('rc', rank);\n    const dtype = getCoordsDataType(rank);\n    const sourceCoords = getSourceCoords(rank, channels);\n    const innerDims = channels.slice(-2);\n    const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n\n    this.userCode = `\n      void main() {\n        ${dtype} rc = getOutputCoords();\n        vec4 packedInput = getA(${sourceCoords});\n\n        setOutput(getChannel(packedInput, ${coords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import webgl flags.\nimport './flags_webgl';\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {DataId, div, engine, env, max, MemoryInfo, range, RecursiveArray, reshape, scalar, softmax, tensor, tidy, TimingInfo, transpose} from '@tensorflow/tfjs-core';\nimport {backend_util, buffer, kernel_impls, slice_util, util} from '@tensorflow/tfjs-core';\nimport {DataStorage, DataType, KernelBackend, NumericDataType, Rank, Scalar, ShapeMap, Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D, Tensor5D, TensorInfo, TypedArray, upcastType} from '@tensorflow/tfjs-core';\n\nimport {ceilImplCPU, expImplCPU, expm1ImplCPU, floorImplCPU, logImplCPU, rsqrtImplCPU, simpleAbsImplCPU, sliceImplCPU} from './kernel_utils/shared';\n\nconst {segment_util} = backend_util;\nconst split = kernel_impls.split;\nconst tile = kernel_impls.tile;\nconst topkImpl = kernel_impls.topkImpl;\nconst whereImpl = kernel_impls.whereImpl;\n\nimport {AddNProgram} from './addn_gpu';\nimport {AddNPackedProgram} from './addn_packed_gpu';\nimport {ArgMinMaxProgram} from './argminmax_gpu';\nimport {ArgMinMaxPackedProgram} from './argminmax_packed_gpu';\nimport {AvgPool3DBackpropProgram} from './avg_pool_backprop_gpu';\nimport * as binaryop_gpu from './binaryop_gpu';\nimport {BinaryOpProgram} from './binaryop_gpu';\nimport * as binaryop_packed_gpu from './binaryop_packed_gpu';\nimport {BinaryOpPackedProgram} from './binaryop_packed_gpu';\nimport {getWebGLContext} from './canvas_util';\nimport {ClipProgram} from './clip_gpu';\nimport {ClipPackedProgram} from './clip_packed_gpu';\nimport {ComplexAbsProgram} from './complex_abs_gpu';\nimport {Conv2DDerFilterProgram, Conv2DDerInputProgram, Conv3DDerFilterProgram, Conv3DDerInputProgram} from './conv_backprop_gpu';\nimport {DepthwiseConv2DDerFilterProgram, DepthwiseConv2DDerInputProgram} from './conv_backprop_gpu_depthwise';\nimport {Conv2DProgram, Conv3DProgram} from './conv_gpu';\nimport {DepthwiseConv2DProgram} from './conv_gpu_depthwise';\nimport {DepthwiseConvPacked2DProgram} from './conv_packed_gpu_depthwise';\nimport {CropAndResizeProgram} from './crop_and_resize_gpu';\nimport {CumSumProgram} from './cumsum_gpu';\nimport {DecodeMatrixProgram} from './decode_matrix_gpu';\nimport {DecodeMatrixPackedProgram} from './decode_matrix_packed_gpu';\nimport {DepthToSpaceProgram} from './depth_to_space_gpu';\nimport {DiagProgram} from './diag_gpu';\nimport {EncodeFloatProgram} from './encode_float_gpu';\nimport {EncodeFloatPackedProgram} from './encode_float_packed_gpu';\nimport {EncodeMatrixProgram} from './encode_matrix_gpu';\nimport {EncodeMatrixPackedProgram} from './encode_matrix_packed_gpu';\nimport {FillProgram} from './fill_gpu';\nimport {GatherProgram} from './gather_gpu';\nimport {GatherNDProgram} from './gather_nd_gpu';\nimport {GPGPUContext} from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport {GPGPUBinary, GPGPUProgram, TensorData} from './gpgpu_math';\nimport {Im2ColPackedProgram} from './im2col_packed_gpu';\nimport {LRNProgram} from './lrn_gpu';\nimport {LRNGradProgram} from './lrn_grad_gpu';\nimport {LRNPackedProgram} from './lrn_packed_gpu';\nimport {MaxPool3DBackpropProgram} from './max_pool_backprop_gpu';\nimport {MatMulPackedProgram} from './mulmat_packed_gpu';\nimport {MultinomialProgram} from './multinomial_gpu';\nimport {OneHotProgram} from './onehot_gpu';\nimport {PackProgram} from './pack_gpu';\nimport {PadProgram} from './pad_gpu';\nimport {PadPackedProgram} from './pad_packed_gpu';\nimport {Pool3DProgram} from './pool_gpu';\nimport {ReduceProgram} from './reduce_gpu';\nimport {ReshapePackedProgram} from './reshape_packed_gpu';\nimport {ResizeBilinearBackpropProgram} from './resize_bilinear_backprop_gpu';\nimport {ResizeBilinearProgram} from './resize_bilinear_gpu';\nimport {ResizeBilinearPackedProgram} from './resize_bilinear_packed_gpu';\nimport {ResizeNearestNeigborBackpropProgram} from './resize_nearest_neighbor_backprop_gpu';\nimport {ResizeNearestNeighborProgram} from './resize_nearest_neighbor_gpu';\nimport {ReverseProgram} from './reverse_gpu';\nimport {ReversePackedProgram} from './reverse_packed_gpu';\nimport {ScatterProgram} from './scatter_gpu';\nimport {SegmentOpProgram} from './segment_gpu';\nimport {SelectProgram} from './select_gpu';\nimport {SliceProgram} from './slice_gpu';\nimport {SlicePackedProgram} from './slice_packed_gpu';\nimport {StridedSliceProgram} from './strided_slice_gpu';\nimport * as tex_util from './tex_util';\nimport {TextureData, TextureUsage} from './tex_util';\nimport {TextureManager} from './texture_manager';\nimport {TileProgram} from './tile_gpu';\nimport * as unary_op from './unaryop_gpu';\nimport {UnaryOpProgram} from './unaryop_gpu';\nimport * as unary_packed_op from './unaryop_packed_gpu';\nimport {UnaryOpPackedProgram} from './unaryop_packed_gpu';\nimport {UnpackProgram} from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\nimport {BackendValues} from '@tensorflow/tfjs-core';\n\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n\ntype KernelInfo = {\n  name: string; query: Promise<number>;\n};\n\nexport type TimerNode = RecursiveArray<KernelInfo>|KernelInfo;\nexport interface CPUTimerQuery {\n  startMs: number;\n  endMs?: number;\n}\n\nexport interface WebGLMemoryInfo extends MemoryInfo {\n  numBytesInGPU: number;\n  // Tracks the total number of bytes allocated on the GPU, accounting for the\n  // physical texture type.\n  numBytesInGPUAllocated: number;\n  // Tracks byte size of textures that were created and then made available for\n  // reuse (disposed).\n  numBytesInGPUFree: number;\n  unreliable: boolean;\n}\n\nexport interface WebGLTimingInfo extends TimingInfo {\n  uploadWaitMs: number;\n  downloadWaitMs: number;\n}\n\nconst binaryCaches: {[webGLVersion: string]: {[key: string]: GPGPUBinary}} = {};\n\nexport function getBinaryCache(webGLVersion: number) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n}\n\nfunction mapActivationToShaderProgram(\n    activation: backend_util.Activation, packed = false): string {\n  if (activation === 'linear') {\n    if (packed) {\n      return unary_packed_op.LINEAR;\n    }\n    return unary_op.LINEAR;\n  } else if (activation === 'relu') {\n    if (packed) {\n      return unary_packed_op.RELU;\n    }\n    return unary_op.RELU;\n  } else if (activation === 'elu') {\n    if (packed) {\n      return unary_packed_op.ELU;\n    }\n    return unary_op.ELU;\n  } else if (activation === 'relu6') {\n    if (packed) {\n      return unary_packed_op.RELU6;\n    }\n    return unary_op.RELU6;\n  } else if (activation === 'prelu') {\n    if (packed) {\n      return binaryop_packed_gpu.PRELU;\n    }\n    return binaryop_gpu.PRELU;\n  }\n  throw new Error(`Activation ${\n      activation} has not been implemented for the WebGL backend.`);\n}\n\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD = 128;\n\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning(): number {\n  if (env().global.screen == null) {\n    return 1024;  // 1 GB.\n  }\n  return (env().global.screen.height * env().global.screen.width *\n          window.devicePixelRatio) *\n      BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\n\n// Empirically determined minimal shared dimension in matmul before we forward\n// to a.mul(b).sum() in order to take advantage of GPU parallelism. See\n// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.\nexport const MATMUL_SHARED_DIM_THRESHOLD = 1000;\n\nexport class MathBackendWebGL extends KernelBackend {\n  texData: DataStorage<TextureData>;\n  gpgpu: GPGPUContext;\n\n  // Maps data ids that have a pending read operation, to list of subscribers.\n  private pendingRead = new WeakMap<DataId, Array<(arr: TypedArray) => void>>();\n  // List of data ids that are scheduled for disposal, but are waiting on a\n  // pending read operation.\n  private pendingDisposal = new WeakSet<DataId>();\n  // Used to count the number of 'shallow' sliced tensors that point to the\n  // same data id.\n  private dataRefCount = new WeakMap<DataId, number>();\n  private numBytesInGPU = 0;\n\n  private canvas: HTMLCanvasElement|OffscreenCanvas;\n\n  private programTimersStack: TimerNode[];\n  private activeTimers: TimerNode[];\n  // Accumulated time spent (including blocking) in uploading data to webgl.\n  private uploadWaitMs = 0;\n  // Accumulated time spent (including blocking in downloading data from webgl.\n  private downloadWaitMs = 0;\n  private cpuBackend: KernelBackend;\n\n  // Number of bits of precision of this backend.\n  private floatPrecisionValue: 32|16;\n\n  private textureManager: TextureManager;\n  private binaryCache: {[key: string]: GPGPUBinary};\n  private gpgpuCreatedLocally: boolean;\n  private numMBBeforeWarning: number;\n  private warnedAboutMemory = false;\n  private warnedAboutCPUBackend = false;\n\n  constructor(gpgpu?: GPGPUContext) {\n    super();\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n\n    if (gpgpu == null) {\n      const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      this.gpgpu = new GPGPUContext(gl);\n      this.canvas = gl.canvas;\n      this.gpgpuCreatedLocally = true;\n    } else {\n      this.gpgpu = gpgpu;\n      this.binaryCache = {};\n      this.gpgpuCreatedLocally = false;\n      this.canvas = gpgpu.gl.canvas;\n    }\n    this.textureManager = new TextureManager(this.gpgpu);\n    this.numMBBeforeWarning = numMBBeforeWarning();\n\n    this.texData = new DataStorage(this, engine());\n  }\n\n  numDataIds() {\n    return this.texData.numDataIds() +\n        (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) -\n        this.pendingDeletes;\n  }\n\n  write(values: BackendValues, shape: number[], dtype: DataType): DataId {\n    if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n        env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    const dataId = {};\n    this.texData.set(dataId, {\n      shape,\n      dtype,\n      values,\n      usage: TextureUsage.UPLOAD,\n      refCount: 1,\n      complexParentRefCount: 0\n    });\n    return dataId;\n  }\n\n  /** Increase refCount of a `TextureData`. */\n  incRef(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    texData.refCount++;\n  }\n\n  /** Decrease refCount of a `TextureData`. */\n  decRef(dataId: DataId): void {\n    if (this.texData.has(dataId)) {\n      const texData = this.texData.get(dataId);\n      texData.refCount--;\n    }\n  }\n\n  move(dataId: DataId, values: BackendValues, shape: number[], dtype: DataType):\n      void {\n    if (env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64') {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    this.texData.set(dataId, {\n      shape,\n      dtype,\n      values,\n      usage: TextureUsage.UPLOAD,\n      refCount: 1,\n      complexParentRefCount: 0\n    });\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo: TensorInfo): void {\n    const dataId = tensorInfo.dataId;\n\n    if (this.texData.has(dataId)) {\n      const textureData = this.texData.get(dataId);\n\n      textureData.refCount--;\n\n      if (textureData.refCount < 1) {\n        this.disposeData(dataId);\n      }\n    }\n  }\n\n  readSync(dataId: DataId): BackendValues {\n    const texData = this.texData.get(dataId);\n    const {values, dtype, complexTensorInfos, slice, shape, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.readSync(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n    if (dtype === 'string') {\n      return values;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let result: Float32Array;\n    if (dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    } else {\n      result = this.getValuesFromTexture(dataId);\n    }\n\n    if (shouldTimeProgram) {\n      this.downloadWaitMs += util.now() - start;\n    }\n    return this.convertAndCacheOnCPU(dataId, result);\n  }\n\n  async read(dataId: DataId): Promise<BackendValues> {\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<TypedArray>(resolve => subscribers.push(resolve));\n    }\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, complexTensorInfos, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.read(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n\n    if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n        env().getNumber('WEBGL_VERSION') === 2) {\n      throw new Error(\n          `tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n          `WEBGL_VERSION=2 not yet supported.`);\n    }\n\n    let buffer = null;\n    let tmpDownloadTarget: TensorInfo;\n\n    if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n      // Possibly copy the texture into a buffer before inserting a fence.\n      tmpDownloadTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n\n      buffer = this.gpgpu.createBufferFromTexture(\n          tmpData.texture, ...tex_util.getDenseTexShape(shape));\n    }\n\n    this.pendingRead.set(dataId, []);\n\n    if (dtype !== 'complex64') {\n      // Create a fence and wait for it to resolve.\n      await this.gpgpu.createAndWaitForFence();\n    }\n\n    // Download the values from the GPU.\n    let vals: Float32Array;\n    if (dtype === 'complex64') {\n      const ps = await Promise.all([\n        this.read(complexTensorInfos.real.dataId),\n        this.read(complexTensorInfos.imag.dataId)\n      ]);\n\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(\n          realValues as Float32Array, imagValues as Float32Array);\n    } else if (buffer == null) {\n      vals = this.getValuesFromTexture(dataId);\n    } else {\n      const size = util.sizeFromShape(shape);\n      vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n    }\n    if (tmpDownloadTarget != null) {\n      this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n    }\n    const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n\n    const subscribers = this.pendingRead.get(dataId);\n    this.pendingRead.delete(dataId);\n\n    // Notify all pending reads.\n    subscribers.forEach(resolve => resolve(dTypeVals));\n    if (this.pendingDisposal.has(dataId)) {\n      this.pendingDisposal.delete(dataId);\n      this.disposeData(dataId);\n      this.pendingDeletes--;\n    }\n    return dTypeVals;\n  }\n\n  private checkNumericalProblems(values: BackendValues): void {\n    if (values == null) {\n      return;\n    }\n    for (let i = 0; i < values.length; i++) {\n      const num = values[i] as number;\n      if (!webgl_util.canBeRepresented(num)) {\n        if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n          throw Error(\n              `The value ${num} cannot be represented with your ` +\n              `current settings. Consider enabling float32 rendering: ` +\n              `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n        }\n        throw Error(`The value ${num} cannot be represented on this device.`);\n      }\n    }\n  }\n\n  private getValuesFromTexture(dataId: DataId): Float32Array {\n    const {shape, dtype, isPacked} = this.texData.get(dataId);\n    const size = util.sizeFromShape(shape);\n    if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n      const tmpTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpTarget.dataId);\n      const vals = this.gpgpu\n                       .downloadMatrixFromPackedTexture(\n                           tmpData.texture, ...tex_util.getDenseTexShape(shape))\n                       .subarray(0, size);\n\n      this.disposeIntermediateTensorInfo(tmpTarget);\n\n      return vals;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK') && isPacked === true;\n    const outputShape =\n        shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n    const program = shouldUsePackedProgram ?\n        new EncodeFloatPackedProgram(outputShape as [number, number, number]) :\n        new EncodeFloatProgram(outputShape);\n    const output = this.runWebGLProgram(\n        program, [{shape: outputShape, dtype, dataId}], 'float32');\n    const tmpData = this.texData.get(output.dataId);\n    const vals =\n        this.gpgpu\n            .downloadByteEncodedFloatMatrixFromOutputTexture(\n                tmpData.texture, tmpData.texShape[0], tmpData.texShape[1])\n            .subarray(0, size);\n    this.disposeIntermediateTensorInfo(output);\n\n    return vals;\n  }\n\n  async time(f: () => void): Promise<WebGLTimingInfo> {\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers: TimerNode[] = [];\n\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n\n    f();\n\n    // needing to split these up because util.flatten only accepts certain types\n    const flattenedActiveTimerQueries =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.query))\n            .filter(d => d != null);\n    const flattenedActiveTimerNames =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.name))\n            .filter(d => d != null);\n\n    this.activeTimers = oldActiveTimers;\n\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n\n    const res: WebGLTimingInfo = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null  // will be filled by the engine\n    };\n\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n\n      res['kernelMs'] = util.sum(kernelMs);\n      res['getExtraProfileInfo'] = () =>\n          kernelMs.map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d}))\n              .map(d => `${d.name}: ${d.ms}`)\n              .join(', ');\n    } else {\n      res['kernelMs'] = {\n        error: 'WebGL query timers are not supported in this environment.'\n      };\n    }\n\n    this.uploadWaitMs = 0;\n    this.downloadWaitMs = 0;\n    return res;\n  }\n  memory(): WebGLMemoryInfo {\n    return {\n      unreliable: false,\n      numBytesInGPU: this.numBytesInGPU,\n      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n      numBytesInGPUFree: this.textureManager.numBytesFree\n    } as WebGLMemoryInfo;\n  }\n\n  private startTimer(): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.beginQuery();\n    }\n    return {startMs: util.now(), endMs: null};\n  }\n\n  private endTimer(query: WebGLQuery|CPUTimerQuery): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      this.gpgpu.endQuery();\n      return query;\n    }\n    (query as CPUTimerQuery).endMs = util.now();\n    return query;\n  }\n\n  private async getQueryTime(query: WebGLQuery|CPUTimerQuery): Promise<number> {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.waitForQueryAndGetTime(query as WebGLQuery);\n    }\n    const timerQuery = query as CPUTimerQuery;\n    return timerQuery.endMs - timerQuery.startMs;\n  }\n\n  private pendingDeletes = 0;\n\n  disposeData(dataId: DataId): void {\n    if (this.pendingDisposal.has(dataId)) {\n      return;\n    }\n    if (this.pendingRead.has(dataId)) {\n      this.pendingDisposal.add(dataId);\n      this.pendingDeletes++;\n      return;\n    }\n    // No-op if already disposed.\n    if (!this.texData.has(dataId)) {\n      return;\n    }\n\n    // Trying to dispose a textureData that has a 'kept' refCount, e.g. trying\n    // to dispose a tensor whose data bucket is shared with a complex tensor. In\n    // this case we are removing a reference to the textureData, but we\n    // shouldn't actually dispose the texture.\n    if (this.texData.get(dataId).complexParentRefCount > 0) {\n      this.texData.get(dataId).refCount--;\n      return;\n    }\n\n    this.releaseGPUData(dataId);\n    const {complexTensorInfos} = this.texData.get(dataId);\n    if (complexTensorInfos != null) {\n      this.texData.get(complexTensorInfos.real.dataId).complexParentRefCount--;\n      this.disposeIntermediateTensorInfo(complexTensorInfos.real);\n\n      this.texData.get(complexTensorInfos.imag.dataId).complexParentRefCount--;\n      this.disposeIntermediateTensorInfo(complexTensorInfos.imag);\n    }\n    this.texData.delete(dataId);\n  }\n\n  private releaseGPUData(dataId: DataId): void {\n    const {texture, dtype, texShape, usage, isPacked, slice} =\n        this.texData.get(dataId);\n    const key = slice && slice.origDataId || dataId;\n    const refCount = this.dataRefCount.get(key);\n    if (refCount > 1) {\n      this.dataRefCount.set(key, refCount - 1);\n    } else {\n      this.dataRefCount.delete(key);\n      if (texture != null) {\n        this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n        this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n      }\n    }\n    const texData = this.texData.get(dataId);\n    texData.texture = null;\n    texData.texShape = null;\n    texData.isPacked = false;\n    texData.slice = null;\n  }\n\n  getTexture(dataId: DataId): WebGLTexture {\n    this.uploadToGPU(dataId);\n    return this.texData.get(dataId).texture;\n  }\n\n  /**\n   * Returns internal information for the specific data bucket. Used in unit\n   * tests.\n   */\n  getDataInfo(dataId: DataId): TextureData {\n    return this.texData.get(dataId);\n  }\n\n  private getCPUBackend(): KernelBackend|null {\n    if (!env().getBool('WEBGL_CPU_FORWARD')) {\n      return null;\n    }\n\n    if (this.cpuBackend == null) {\n      this.cpuBackend = engine().findBackend('cpu');\n    }\n\n    return this.cpuBackend;\n  }\n\n  /*\n  Tests whether all the inputs to an op are small and on the CPU. This heuristic\n  determines when it would be faster to execute a kernel on the CPU. WebGL\n  kernels opt into running this check and forwarding when appropriate.\n  TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n  sustainable strategy for optimizing backend execution of ops.\n   */\n  shouldExecuteOnCPU(\n      inputs: TensorInfo[],\n      sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD): boolean {\n    const cpuBackend = this.getCPUBackend();\n    if (!this.warnedAboutCPUBackend && cpuBackend == null) {\n      console.warn(\n          'Your application contains ops that are small enough to be ' +\n          'executed on the CPU backend, however the CPU backend cannot ' +\n          'be found. Consider importing the CPU backend ' +\n          '(@tensorflow/tfjs-backend-cpu) for better performance.');\n\n      this.warnedAboutCPUBackend = true;\n    }\n\n    return cpuBackend != null &&\n        inputs.every(\n            input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n\n  getGPGPUContext(): GPGPUContext {\n    return this.gpgpu;\n  }\n\n  slice<T extends Tensor>(x: T, begin: number[], size: number[]): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      const outValues = sliceImplCPU(\n          this.texData.get(x.dataId).values as TypedArray, begin, size, x.shape,\n          x.dtype);\n      return this.makeOutput(size, x.dtype, outValues);\n    }\n    // Short-circuit computation if the slice is zero-sized.\n    if (util.sizeFromShape(size) === 0) {\n      return tensor([], size, x.dtype) as T;\n    }\n    const {isPacked} = this.texData.get(x.dataId);\n    const isContinous = slice_util.isSliceContinous(x.shape, begin, size);\n    if (isPacked || !isContinous) {\n      const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n          new SlicePackedProgram(size) :\n          new SliceProgram(size);\n      const customSetup = program.getCustomSetupFunc(begin);\n      return this.compileAndRun(program, [x], null, customSetup);\n    }\n    this.uploadToGPU(x.dataId);\n    return this.shallowSlice(x, begin, size) as T;\n  }\n\n  private shallowSlice(x: Tensor, begin: number[], size: number[]): Tensor {\n    const xTexData = this.texData.get(x.dataId);\n    const t = this.makeOutput(size, x.dtype);\n    const newTexData = this.texData.get(t.dataId);\n    // Copy texture data from the original tensor.\n    Object.assign(newTexData, xTexData);\n    newTexData.shape = size;\n    newTexData.dtype = x.dtype;\n    let flatOffset = slice_util.computeFlatOffset(begin, x.strides);\n    if (xTexData.slice) {\n      // We are slicing an already sliced tensor, so we have to accumulate\n      // the offset.\n      flatOffset += xTexData.slice.flatOffset;\n    }\n    newTexData.slice = {\n      flatOffset,\n      // Point to the original dataId, which is used to do ref counting.\n      origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n    };\n\n    // Increase the ref count for that data bucket.\n    const refCount = this.dataRefCount.get(newTexData.slice.origDataId) || 1;\n    this.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n\n    return t;\n  }\n\n  stridedSlice<T extends Tensor>(\n      x: T, begin: number[], end: number[], strides: number[]): T {\n    const cpuRes = this.tryRunOnCpuOrThrow(\n        [x], () => this.cpuBackend.stridedSlice(x, begin, end, strides));\n    if (cpuRes) {\n      return cpuRes;\n    }\n\n    const outShape = slice_util.computeOutShape(begin, end, strides);\n\n    if (outShape.some(axis => axis === 0)) {\n      return tensor([], outShape) as T;\n    }\n\n    const program = new StridedSliceProgram(begin, strides, outShape);\n    return this.compileAndRun(program, [x]);\n  }\n\n  reverse<T extends Tensor>(x: T, axis: number[]): T {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new ReversePackedProgram(x.shape, axis) :\n        new ReverseProgram(x.shape, axis);\n    return this.compileAndRun(program, [x]);\n  }\n\n  neg<T extends Tensor>(x: T): T {\n    const cpuRes = this.tryRunOnCpuOrThrow([x], () => this.cpuBackend.neg(x));\n    if (cpuRes) {\n      return cpuRes;\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.NEG, x.dtype) as T;\n    }\n    const program = new UnaryOpProgram(x.shape, unary_op.NEG);\n    return this.compileAndRun(program, [x]);\n  }\n\n  batchMatMul(\n      a: Tensor3D, b: Tensor3D, transposeA: boolean,\n      transposeB: boolean): Tensor3D {\n    const outerShapeA = transposeA ? a.shape[2] : a.shape[1];\n    const outerShapeB = transposeB ? b.shape[1] : b.shape[2];\n    const sharedDim = transposeA ? a.shape[1] : a.shape[2];\n    const batch = Math.max(a.shape[0], b.shape[0]);\n\n    // Since the matrices are vectors, it is faster to call mul().sum()\n    // because sum() is O(sqrt(N)) due to divide-and-conquer.\n    if ((outerShapeA === 1 || outerShapeB === 1) &&\n        sharedDim > MATMUL_SHARED_DIM_THRESHOLD) {\n      if (transposeA) {\n        a = transpose(a, [0, 2, 1]);\n      }\n      if (transposeB) {\n        b = transpose(b, [0, 2, 1]);\n      }\n\n      const a3D = outerShapeB === 1 ? a : a.as3D(batch, sharedDim, 1);\n      const axis = outerShapeB === 1 ? 2 : 1;\n      const b3D = outerShapeB === 1 ? b.as3D(batch, 1, sharedDim) : b;\n      // TODO(annxingyuan): Call multiply directly as part of batchMatMul\n      // modularization.\n      const product = tf.mul(a3D, b3D);\n      return product.sum(axis, true /* keepDims */);\n    }\n\n    const dtype = upcastType(a.dtype, b.dtype);\n\n    const program = new MatMulPackedProgram(\n        a.shape, b.shape, [batch, outerShapeA, outerShapeB], transposeA,\n        transposeB);\n    return this.compileAndRun<Tensor3D>(program, [a, b], dtype);\n  }\n\n  fusedBatchMatMul(\n      {a, b, transposeA, transposeB, bias, activation, preluActivationWeights}:\n          backend_util.FusedBatchMatMulConfig): Tensor3D {\n    const outerShapeA = transposeA ? a.shape[2] : a.shape[1];\n    const outerShapeB = transposeB ? b.shape[1] : b.shape[2];\n    const batch = Math.max(a.shape[0], b.shape[0]);\n\n    const dtype = upcastType(a.dtype, b.dtype);\n\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const fusedActivation =\n        activation ? mapActivationToShaderProgram(activation, true) : null;\n    const program = new MatMulPackedProgram(\n        a.shape, b.shape, [batch, outerShapeA, outerShapeB], transposeA,\n        transposeB, hasBias, fusedActivation, hasPreluActivationWeights);\n    const inputs: TensorInfo[] = [a, b];\n    if (bias) {\n      inputs.push(bias);\n    }\n    if (preluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    return this.compileAndRun<Tensor3D>(program, inputs, dtype);\n  }\n\n  localResponseNormalization4D(\n      x: Tensor4D, radius: number, bias: number, alpha: number,\n      beta: number): Tensor4D {\n    const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n        new LRNPackedProgram(x.shape, radius, bias, alpha, beta) :\n        new LRNProgram(x.shape, radius, bias, alpha, beta);\n    return this.compileAndRun(program, [x]);\n  }\n\n  LRNGrad(\n      dy: Tensor4D, inputImage: Tensor4D, outputImage: Tensor4D,\n      depthRadius: number, bias: number, alpha: number,\n      beta: number): Tensor4D {\n    const program =\n        new LRNGradProgram(inputImage.shape, depthRadius, bias, alpha, beta);\n    return this.compileAndRun(program, [inputImage, outputImage, dy]);\n  }\n\n  tile<T extends Tensor>(x: T, reps: number[]): T {\n    if (x.dtype === 'string') {\n      const data = this.readSync(x.dataId) as Uint8Array[];\n      const decodedData = data.map(d => util.decodeString(d));\n      const buf = buffer(x.shape, x.dtype, decodedData);\n      return tile(buf, reps) as T;\n    }\n    const program = new TileProgram(x.shape, reps);\n    return this.compileAndRun(program, [x]);\n  }\n\n  pad<T extends Tensor>(\n      x: T, paddings: Array<[number, number]>, constantValue: number): T {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new PadPackedProgram(x.shape, paddings, constantValue) :\n        new PadProgram(x.shape, paddings, constantValue);\n    return this.compileAndRun(program, [x]);\n  }\n\n  gather<T extends Tensor>(x: T, indices: Tensor1D, axis: number): T {\n    const cpuRes = this.tryRunOnCpuOrThrow(\n        [x, indices], () => this.cpuBackend.gather(x, indices, axis));\n    if (cpuRes) {\n      return cpuRes;\n    }\n\n    const program = new GatherProgram(x.shape, indices.size, axis);\n    return this.compileAndRun(program, [x, indices]);\n  }\n\n  batchToSpaceND<T extends Tensor>(\n      x: T, blockShape: number[], crops: number[][]): T {\n    util.assert(\n        x.rank <= 4,\n        () => 'batchToSpaceND for rank > 4 with a WebGL backend not ' +\n            'implemented yet');\n    const prod = blockShape.reduce((a, b) => a * b);\n\n    const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n    const permuted =\n        backend_util.getPermuted(reshaped.length, blockShape.length);\n    const reshapedPermuted =\n        backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n    const sliceBeginCoords =\n        backend_util.getSliceBeginCoords(crops, blockShape.length);\n    const sliceSize =\n        backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n\n    return transpose(x.reshape(reshaped), permuted)\n               .reshape(reshapedPermuted)\n               .slice(sliceBeginCoords, sliceSize) as T;\n  }\n\n  spaceToBatchND<T extends Tensor>(\n      x: T, blockShape: number[], paddings: Array<[number, number]>): T {\n    util.assert(\n        x.rank <= 4,\n        () => 'spaceToBatchND for rank > 4 with a WebGL backend not ' +\n            'implemented yet');\n\n    const prod = blockShape.reduce((a, b) => a * b);\n\n    const completePaddings: Array<[number, number]> = [[0, 0]];\n    completePaddings.push(...paddings);\n    for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {\n      completePaddings.push([0, 0]);\n    }\n\n    const paddedX = x.pad(completePaddings);\n\n    const reshapedPaddedShape =\n        backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n\n    const permutedReshapedPaddedPermutation = backend_util.getPermuted(\n        reshapedPaddedShape.length, blockShape.length, false);\n\n    const flattenShape = backend_util.getReshapedPermuted(\n        paddedX.shape, blockShape, prod, false);\n\n    const paddedXT = transpose(\n        paddedX.reshape(reshapedPaddedShape),\n        permutedReshapedPaddedPermutation);\n    return reshape(paddedXT, flattenShape) as T;\n  }\n\n  private reduce(\n      x: Tensor2D, reduceType: 'all'|'any'|'max'|'min'|'sum'|'prod',\n      dtype: DataType): Tensor2D {\n    const batchSize = x.shape[0];\n    const inSize = x.shape[1];\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const outSize = Math.ceil(inSize / windowSize);\n    const reduceInfo = {windowSize, inSize, batchSize, outSize};\n    const program = new ReduceProgram(reduceInfo, reduceType);\n    const output = this.compileAndRun<Tensor2D>(program, [x], dtype);\n    // No need to run another GPGPU program.\n    if (output.shape[1] === 1) {\n      return output;\n    }\n    return this.reduce(output, reduceType, dtype);\n  }\n\n  private argReduce(\n      x: Tensor2D, reduceType: 'max'|'min',\n      bestIndicesA: Tensor2D = null): Tensor2D {\n    let batchSize = x.shape[0];\n    let inSize = x.shape[1];\n    if (bestIndicesA != null) {\n      batchSize = bestIndicesA.shape[0];\n      inSize = bestIndicesA.shape[1];\n    }\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const reduceInfo = {\n      windowSize,\n      inSize,\n      batchSize,\n      outSize: Math.ceil(inSize / windowSize)\n    };\n    const program =\n        new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);\n    const inputs = [x];\n    if (bestIndicesA != null) {\n      inputs.push(bestIndicesA);\n    }\n    const output = this.compileAndRun<Tensor2D>(program, inputs, 'int32');\n    // No need to run another GPGPU program.\n    if (output.shape[1] === 1) {\n      return output;\n    }\n    return this.argReduce(x, reduceType, output);\n  }\n\n  private argReducePacked(\n      x: Tensor, reduceType: 'max'|'min', bestIndicesA: Tensor = null): Tensor {\n    const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;\n    const inSize = inShape[inShape.length - 1];\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const program = new ArgMinMaxPackedProgram(\n        inShape, windowSize, reduceType, bestIndicesA == null);\n    const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];\n    const output = this.compileAndRun<Tensor>(program, inputs, 'int32');\n    if (output.rank === x.rank) {\n      return this.argReducePacked(x, reduceType, output);\n    }\n    return output;\n  }\n\n  sum(x: Tensor, axes: number[]): Tensor {\n    backend_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    const outputDType = tf.sumOutType(x.dtype);\n    return this.reduce(a2D, 'sum', outputDType).reshape(outShape);\n  }\n\n  prod(x: Tensor, axes: number[]): Tensor {\n    const cpuRes =\n        this.tryRunOnCpuOrThrow([x], () => this.cpuBackend.prod(x, axes));\n    if (cpuRes) {\n      return cpuRes;\n    }\n\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    const outputDType = tf.sumOutType(x.dtype);\n    return this.reduce(a2D, 'prod', outputDType).reshape(outShape);\n  }\n\n  unsortedSegmentSum<T extends Tensor>(\n      x: T, segmentIds: Tensor1D, numSegments: number): Tensor {\n    let axis = 0;\n    const permutation = backend_util.getAxesPermutation([axis], x.rank);\n    let permutedX = x;\n    if (permutation != null) {\n      permutedX = transpose(x, permutation);\n      axis = backend_util.getInnerMostAxes(1, x.rank)[0];\n    }\n\n    const outShape =\n        segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n    const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n    const a2D = permutedX.as2D(-1, inSize);\n    const outputDType = tf.sumOutType(x.dtype);\n    let result =\n        this.segOpCompute(\n                a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments)\n            .reshape(outShape);\n    if (permutation != null) {\n      result =\n          transpose(result, backend_util.getUndoAxesPermutation(permutation));\n    }\n    return result;\n  }\n\n  private segOpCompute(\n      x: Tensor2D, segOpType: 'unsortedSegmentSum', segmentIds: Tensor1D,\n      dtype: DataType, numSegments: number): Tensor2D {\n    const batchSize = x.shape[0];\n    const inSize = x.shape[1];\n    const windowSize =\n        segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n    const segOpInfo = {windowSize, inSize, batchSize, numSegments};\n    const program = new SegmentOpProgram(segOpInfo, segOpType);\n    const output =\n        this.compileAndRun<Tensor2D>(program, [x, segmentIds], dtype);\n    // No need to run another GPGPU program.\n    if (output.shape[1] === numSegments) {\n      return output;\n    }\n    segmentIds = range(0, numSegments).tile([inSize / windowSize]);\n    return this.segOpCompute(output, segOpType, segmentIds, dtype, numSegments);\n  }\n\n  private argMinMaxReduce(x: Tensor, axis: number, reduceType: 'min'|'max'):\n      Tensor {\n    const axes = [axis];\n    backend_util.assertAxesAreInnerMostDims(\n        'arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes,\n        x.rank);\n    if (!env().getBool('WEBGL_PACK_REDUCE') || x.rank <= 2) {\n      const [outShape, reduceShape] =\n          backend_util.computeOutAndReduceShapes(x.shape, axes);\n      const inSize = util.sizeFromShape(reduceShape);\n      const a2D = x.as2D(-1, inSize);\n      return this.argReduce(a2D, reduceType).reshape(outShape);\n    }\n    return this.argReducePacked(x, reduceType);\n  }\n\n  argMin(x: Tensor, axis: number): Tensor {\n    return this.argMinMaxReduce(x, axis, 'min');\n  }\n\n  argMax(x: Tensor, axis: number): Tensor {\n    return this.argMinMaxReduce(x, axis, 'max');\n  }\n\n  cumsum(x: Tensor, axis: number, exclusive: boolean, reverse: boolean):\n      Tensor {\n    if (axis !== x.rank - 1) {\n      throw new Error(\n          `WebGL cumsum shader expects an inner-most axis=${x.rank - 1} ` +\n          `but got axis=${axis}`);\n    }\n    const size = x.shape[axis];\n    let result = x;\n    // Use cumsum parallel algorithm, ref:\n    // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda\n    for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {\n      const program = new CumSumProgram(x.shape, false, reverse);\n      const customSetup = program.getCustomSetupFunc(i);\n      const prevResult = result;\n      result = this.compileAndRun(program, [result], result.dtype, customSetup);\n      prevResult.dispose();\n    }\n    // For exclusive cumsum, shift the end result in the direction of sum and\n    // add 0 to the front index.\n    if (exclusive) {\n      const program = new CumSumProgram(x.shape, exclusive, reverse);\n      const prevResult = result;\n      result = this.compileAndRun(program, [result]);\n      prevResult.dispose();\n    }\n\n    return result;\n  }\n\n  equal(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.EQUAL, 'bool');\n    }\n    const program = new BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  less(a: Tensor, b: Tensor): Tensor {\n    const cpuRes =\n        this.tryRunOnCpuOrThrow([a, b], () => this.cpuBackend.less(a, b));\n    if (cpuRes) {\n      return cpuRes;\n    }\n\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.LESS, 'bool');\n    }\n\n    const program = new BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  lessEqual(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.LESS_EQUAL, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  greater(a: Tensor, b: Tensor): Tensor {\n    const cpuRes =\n        this.tryRunOnCpuOrThrow([a, b], () => this.cpuBackend.greater(a, b));\n    if (cpuRes) {\n      return cpuRes;\n    }\n\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.GREATER, 'bool');\n    }\n\n    const program = new BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  greaterEqual(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(\n          a, b, binaryop_packed_gpu.GREATER_EQUAL, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  logicalNot<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);\n    return this.compileAndRun(program, [x]);\n  }\n\n  logicalAnd(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.LOGICAL_AND, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  logicalOr(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.LOGICAL_OR, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  select(condition: Tensor, a: Tensor, b: Tensor): Tensor {\n    const program = new SelectProgram(condition.rank, a.shape, a.rank);\n    return this.compileAndRun(\n        program, [condition, a, b], upcastType(a.dtype, b.dtype));\n  }\n\n  where(condition: Tensor): Tensor2D {\n    backend_util.warn(\n        'tf.where() in webgl locks the UI thread. ' +\n        'Call tf.whereAsync() instead');\n    const condVals = condition.dataSync();\n    return whereImpl(condition.shape, condVals);\n  }\n\n  topk<T extends Tensor>(x: T, k: number, sorted: boolean): [T, T] {\n    const xVals = x.dataSync();\n    return topkImpl(xVals, x.shape, x.dtype as NumericDataType, k, sorted);\n  }\n\n  min(x: Tensor, axes: number[]): Tensor {\n    backend_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);\n  }\n\n  minimum(a: Tensor, b: Tensor): Tensor {\n    const cpuRes =\n        this.tryRunOnCpuOrThrow([a, b], () => this.cpuBackend.minimum(a, b));\n    if (cpuRes) {\n      return cpuRes;\n    }\n\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.MIN, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  }\n\n  mod(a: Tensor, b: Tensor): Tensor {\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.MOD, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.MOD, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  }\n\n  maximum(a: Tensor, b: Tensor): Tensor {\n    const cpuRes =\n        this.tryRunOnCpuOrThrow([a, b], () => this.cpuBackend.maximum(a, b));\n    if (cpuRes) {\n      return cpuRes;\n    }\n\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.MAX, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  }\n\n  all(x: Tensor, axes: number[]): Tensor {\n    backend_util.assertAxesAreInnerMostDims('all', axes, x.rank);\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    return this.reduce(a2D, 'all', a2D.dtype).reshape(outShape);\n  }\n\n  any(x: Tensor, axes: number[]): Tensor {\n    backend_util.assertAxesAreInnerMostDims('any', axes, x.rank);\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    return this.reduce(a2D, 'any', a2D.dtype).reshape(outShape);\n  }\n\n  floorDiv(a: Tensor, b: Tensor): Tensor {\n    const op = binaryop_gpu.INT_DIV;\n    const outputDtype = 'int32';\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(\n          a, b, binaryop_packed_gpu.INT_DIV, outputDtype);\n    }\n    const program = new BinaryOpProgram(op, a.shape, b.shape);\n    return this.compileAndRun<Tensor>(program, [a, b], outputDtype);\n  }\n\n  private packedUnaryOp(x: TensorInfo, op: string, dtype: DataType) {\n    const program = new UnaryOpPackedProgram(x.shape, op);\n    return this.compileAndRun<Tensor>(program, [x], dtype);\n  }\n\n  private packedBinaryOp(\n      a: TensorInfo, b: TensorInfo, op: string, dtype: DataType,\n      checkOutOfBounds = false) {\n    const program =\n        new BinaryOpPackedProgram(op, a.shape, b.shape, checkOutOfBounds);\n    return this.compileAndRun<Tensor>(program, [a, b], dtype);\n  }\n\n  // Returns a TensorInfo with the complex shape and the dataId of the\n  // underlying part. We need to do this because a reshaped complex tensor is\n  // not reflected in its parts.\n  private makeComplexComponentTensorInfo(\n      complexTensor: Tensor, complexPart: TensorInfo): TensorInfo {\n    return {\n      dataId: complexPart.dataId,\n      dtype: complexPart.dtype,\n      shape: complexTensor.shape\n    };\n  }\n\n  addN<T extends Tensor>(tensors: T[]): T {\n    if (tensors.length === 1) {\n      return tensors[0];\n    }\n\n    // Limit the number of uploaded textures for optimization.\n    if (tensors.length > env().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n      const midIndex = Math.floor(tensors.length / 2);\n      const leftSide = this.addN(tensors.slice(0, midIndex));\n      const rightSide = this.addN(tensors.slice(midIndex));\n      return this.addN([leftSide, rightSide]);\n    }\n\n    const dtype =\n        tensors.map(t => t.dtype).reduce((d1, d2) => upcastType(d1, d2));\n    const shapes = tensors.map(t => t.shape);\n    // We can make sure shapes are identical in op level.\n    const usePackedOp = env().getBool('WEBGL_PACK');\n    const program = usePackedOp ?\n        new AddNPackedProgram(tensors[0].shape, shapes) :\n        new AddNProgram(tensors[0].shape, shapes);\n    return this.compileAndRun<T>(program, tensors, dtype);\n  }\n\n  pow<T extends Tensor>(a: T, b: Tensor): T {\n    const usePackedOp = env().getBool('WEBGL_PACK_BINARY_OPERATIONS');\n    const program = usePackedOp ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.POW, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);\n    const dtype = upcastType(a.dtype, b.dtype);\n    return this.compileAndRun<T>(program, [a, b], dtype);\n  }\n\n  ceil<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      const outValues =\n          ceilImplCPU(this.texData.get(x.dataId).values as TypedArray, x.dtype);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.CEIL, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.CEIL);\n    return this.compileAndRun(program, [x]);\n  }\n\n  floor<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      const outValues = floorImplCPU(\n          this.texData.get(x.dataId).values as TypedArray, x.dtype);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.FLOOR, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.FLOOR);\n    return this.compileAndRun(program, [x]);\n  }\n\n  sign<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SIGN);\n    return this.compileAndRun(program, [x]);\n  }\n\n  isNaN<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.IS_NAN);\n    return this.compileAndRun(program, [x], 'bool');\n  }\n  isInf<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.IS_INF);\n    return this.compileAndRun(program, [x], 'bool');\n  }\n  isFinite<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.IS_FINITE);\n    return this.compileAndRun(program, [x], 'bool');\n  }\n\n  round<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ROUND);\n    return this.compileAndRun(program, [x]);\n  }\n\n  exp<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      const outValues =\n          expImplCPU(this.texData.get(x.dataId).values as TypedArray, x.dtype);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.EXP, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.EXP);\n    return this.compileAndRun(program, [x]);\n  }\n\n  expm1<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      const outValues = expm1ImplCPU(\n          this.texData.get(x.dataId).values as TypedArray, x.dtype);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.EXPM1, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.EXPM1);\n    return this.compileAndRun(program, [x]);\n  }\n\n  softmax<T extends Tensor>(logits: T, dim: number): T {\n    const axes = util.parseAxisParam([dim], logits.shape);\n    // TODO(annxingyuan): Call maxImpl rather than op as part of softmax kernel\n    // modularization.\n    const maxLogit = max(logits, axes);\n    const expandedShape =\n        backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n    // TODO(annxingyuan): Call sub directly as part of softmax kernel\n    // modularization.\n    const a = tf.sub(logits, maxLogit.reshape(expandedShape));\n    const b = this.exp(a);\n    const sumExp = this.sum(b, axes).reshape(expandedShape);\n\n    // TODO(annxingyuan): Call divImpl rather than op as part of softmax kernel\n    // modularization.\n    return div(b, sumExp);\n  }\n\n  log<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      const outValues =\n          logImplCPU(this.texData.get(x.dataId).values as TypedArray, x.dtype);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_packed_op.LOG, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.LOG);\n    return this.compileAndRun(program, [x]);\n  }\n\n  log1p<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.LOG1P);\n    return this.compileAndRun(program, [x]);\n  }\n\n  sqrt<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SQRT);\n    return this.compileAndRun(program, [x]);\n  }\n\n  rsqrt<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      const outValues = rsqrtImplCPU(\n          this.texData.get(x.dataId).values as TypedArray, x.dtype);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n    const program = new UnaryOpProgram(x.shape, unary_op.RSQRT);\n    return this.compileAndRun(program, [x]);\n  }\n\n  reciprocal<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.RECIPROCAL);\n    return this.compileAndRun(program, [x]);\n  }\n\n  relu<T extends Tensor>(x: T): T {\n    let program: UnaryOpProgram|UnaryOpPackedProgram;\n    if (env().getBool('WEBGL_PACK')) {\n      program = new UnaryOpPackedProgram(x.shape, unary_packed_op.RELU);\n    } else {\n      program = new UnaryOpProgram(x.shape, unary_op.RELU);\n    }\n    return this.compileAndRun(program, [x]);\n  }\n\n  relu6<T extends Tensor>(x: T): T {\n    let program: UnaryOpProgram|UnaryOpPackedProgram;\n    if (env().getBool('WEBGL_PACK')) {\n      program = new UnaryOpPackedProgram(x.shape, unary_packed_op.RELU6);\n    } else {\n      program = new UnaryOpProgram(x.shape, unary_op.RELU6);\n    }\n    return this.compileAndRun(program, [x]);\n  }\n\n  prelu<T extends Tensor>(x: T, alpha: T): T {\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(\n            binaryop_packed_gpu.PRELU, x.shape, alpha.shape) :\n        new BinaryOpProgram(binaryop_gpu.PRELU, x.shape, alpha.shape);\n    return this.compileAndRun(program, [x, alpha]);\n  }\n\n  elu<T extends Tensor>(x: T): T {\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_packed_op.ELU, x.dtype) as T;\n    }\n    const program = new UnaryOpProgram(x.shape, unary_op.ELU);\n    return this.compileAndRun(program, [x]);\n  }\n\n  eluDer<T extends Tensor>(dy: T, y: T): T {\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(\n            binaryop_packed_gpu.ELU_DER, dy.shape, y.shape) :\n        new BinaryOpProgram(binaryop_gpu.ELU_DER, dy.shape, y.shape);\n    return this.compileAndRun(program, [dy, y]);\n  }\n\n  selu<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SELU);\n    return this.compileAndRun(program, [x]);\n  }\n\n  clip<T extends Tensor>(x: T, min: number, max: number): T {\n    let program;\n    if (env().getBool('WEBGL_PACK_CLIP')) {\n      program = new ClipPackedProgram(x.shape);\n    } else {\n      program = new ClipProgram(x.shape);\n    }\n    const customSetup = program.getCustomSetupFunc(min, max);\n    return this.compileAndRun(program, [x], null, customSetup);\n  }\n\n  abs<T extends Tensor>(x: T): T {\n    // TODO: handle cases when x is complex.\n    if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n      const outValues =\n          simpleAbsImplCPU(this.texData.get(x.dataId).values as TypedArray);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.ABS, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n    return this.compileAndRun(program, [x]);\n  }\n\n  complexAbs<T extends Tensor>(x: T): T {\n    const xData = this.texData.get(x.dataId);\n\n    const program = new ComplexAbsProgram(x.shape);\n    const inputs = [\n      this.makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),\n      this.makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag),\n    ];\n\n    return this.compileAndRun<Tensor>(program, inputs) as T;\n  }\n\n  sigmoid<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SIGMOID);\n    return this.compileAndRun(program, [x]);\n  }\n\n  softplus<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SOFTPLUS);\n    return this.compileAndRun(program, [x]);\n  }\n\n  asin<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ASIN);\n    return this.compileAndRun(program, [x]);\n  }\n\n  acos<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ACOS);\n    return this.compileAndRun(program, [x]);\n  }\n\n  atan<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ATAN);\n    return this.compileAndRun(program, [x]);\n  }\n\n  sinh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SINH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  cosh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.COSH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  tanh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.TANH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  asinh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ASINH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  acosh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ACOSH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  atanh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ATANH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  erf<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ERF);\n    return this.compileAndRun(program, [x]);\n  }\n\n  step<T extends Tensor>(x: T, alpha: number): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.STEP(alpha));\n    return this.compileAndRun(program, [x]);\n  }\n\n  private conv2dByMatMul(\n      x: Tensor4D, filter: Tensor4D, convInfo: backend_util.Conv2DInfo,\n      bias?: Tensor, activation?: backend_util.Activation,\n      preluActivationWeights?: Tensor): Tensor4D {\n    // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the\n    // result from 2D to 4D.\n    const xShape = x.shape;\n    const xTexData = this.texData.get(x.dataId);\n    const sharedMatMulDim = convInfo.inChannels;\n    const outerShapeX = xShape[0] * xShape[1] * xShape[2];\n    const outerShapeFilter = convInfo.outChannels;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    const transposeA = false;\n    const transposeB = false;\n\n    // TODO: Once reduction ops are packed, batchMatMul will always be packed\n    // and we can remove this condition.\n    const batchMatMulWillBeUnpacked =\n        (outerShapeX === 1 || outerShapeFilter === 1) &&\n        sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;\n    const reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;\n\n    if (batchMatMulWillBeUnpacked || !env().getBool('WEBGL_LAZILY_UNPACK') ||\n        !env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ||\n        !reshapeWillBeExpensive) {\n      const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] :\n                                           xShape[0] * xShape[2] * xShape[3];\n      const xReshaped = reshape(x, [1, targetShape, convInfo.inChannels]);\n      const filterReshaped =\n          reshape(filter, [1, convInfo.inChannels, convInfo.outChannels]);\n\n      const result = this.fusedBatchMatMul({\n        a: xReshaped as Tensor3D,\n        b: filterReshaped as Tensor3D,\n        transposeA,\n        transposeB,\n        bias,\n        activation,\n        preluActivationWeights\n      });\n      return reshape(result, convInfo.outShape);\n    }\n\n    // Following optimization is specific to packed |x| with odd row count\n    // (For example, in channelLast mode, 'row count' refers to x.shape[2]):\n    // we avoid expensive packed 2x2 reshape by padding row count to next,\n    // even number. When x.shape[2] is odd, the result of packed batchMatMul is\n    // the same (has the same texture layout and and values in the texture) as\n    // it is for even x.shape[2] + 1. We make the odd-rows tensor to look like\n    // even-rows tensor before the operation and, after the batchMatMul,\n    // fix the even-rows result to have odd number of rows.\n    const targetShape = isChannelsLast ?\n        xShape[0] * xShape[1] * (xShape[2] + 1) :\n        xShape[0] * xShape[2] * (xShape[3] + 1);\n    const xReshaped: TensorInfo = {\n      dataId: x.dataId,\n      shape: [1, targetShape, convInfo.inChannels],\n      dtype: x.dtype\n    };\n    // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.\n    // Decrementing row count, after batchMatMul->...->compileProgram leads to\n    // invalid row count within the reference in GPGPUBinary.inShapeInfos.\n    // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos\n    // in compileProgram method, but that would affect compilation of all\n    // programs - instead, provide a copy here, with even row count, before\n    // calling batchMatMul->...->compileProgram and after that, the original\n    // xTexData.shape is restored.\n    const originalXTexDataShape = xTexData.shape;\n    xTexData.shape = xTexData.shape.slice();\n    xTexData.shape[xTexData.shape.length - 2]++;\n    util.assert(\n        webgl_util.isReshapeFree(xTexData.shape, xReshaped.shape),\n        () => `packed reshape ${xTexData.shape} to ${\n            xReshaped.shape} isn't free`);\n    const filterReshaped =\n        reshape(filter, [1, convInfo.inChannels, convInfo.outChannels]);\n\n    const pointwiseConv = this.fusedBatchMatMul({\n      a: xReshaped as Tensor3D,\n      b: filterReshaped as Tensor3D,\n      transposeA,\n      transposeB,\n      bias,\n      activation,\n      preluActivationWeights\n    });\n    const pointwiseConvTexData = this.texData.get(pointwiseConv.dataId);\n    util.assert(\n        pointwiseConvTexData.isPacked,\n        () => 'batchMatMul result is expected to be packed');\n    // Restore the input shape to original.\n    xTexData.shape = originalXTexDataShape;\n    // Set the output shape - there is no need for expensive reshape as data\n    // layout is already correct.\n    pointwiseConvTexData.shape = convInfo.outShape;\n    return engine().makeTensorFromDataId(\n               pointwiseConv.dataId, convInfo.outShape, pointwiseConv.dtype) as\n        Tensor4D;\n  }\n\n  private conv2dWithIm2Row(\n      x: Tensor4D, filter: Tensor4D, convInfo: backend_util.Conv2DInfo,\n      bias?: Tensor, activation?: backend_util.Activation,\n      preluActivationWeights?: Tensor): Tensor4D {\n    // Rearranges conv2d input so each block to be convolved over forms the\n    // column of a new matrix with shape [filterWidth * filterHeight *\n    // inChannels, outHeight * outWidth]. The filter is also rearranged so each\n    // output channel forms a row of a new matrix with shape [outChannels,\n    // filterWidth * filterHeight * inChannels]. The convolution is then\n    // computed by multiplying these matrices and reshaping the result.\n    const {\n      filterWidth,\n      filterHeight,\n      inChannels,\n      outWidth,\n      outHeight,\n      dataFormat\n    } = convInfo;\n\n    const isChannelsLast = dataFormat === 'channelsLast';\n\n    const sharedDim = filterWidth * filterHeight * inChannels;\n    const numCols = outHeight * outWidth;\n    const x2ColShape = [sharedDim, numCols];\n    const transposeA = true;\n    const transposeB = false;\n\n    const xSqueezed = x.squeeze([0]);\n    const w2Row: Tensor3D = filter.reshape([1, sharedDim, -1]);\n\n    const im2ColProgram =\n        new Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);\n    const im2Col: Tensor3D =\n        this.compileAndRun<Tensor2D>(im2ColProgram, [xSqueezed]).reshape([\n          1, x2ColShape[0], x2ColShape[1]\n        ]);\n\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const fusedActivation =\n        activation ? mapActivationToShaderProgram(activation, true) : null;\n    const matmulProgram = new MatMulPackedProgram(\n        im2Col.shape, w2Row.shape, [1, numCols, convInfo.outChannels],\n        transposeA, transposeB, hasBias, fusedActivation,\n        hasPreluActivationWeights);\n    const inputs: TensorInfo[] = [im2Col, w2Row];\n    if (bias) {\n      inputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    const product = this.compileAndRun<Tensor4D>(matmulProgram, inputs);\n\n    if (isChannelsLast) {\n      return product.reshape([1, outHeight, outWidth, convInfo.outChannels]);\n    } else {\n      return product.reshape([1, convInfo.outChannels, outHeight, outWidth]);\n    }\n  }\n\n  fusedConv2d(\n      {input, filter, convInfo, bias, activation, preluActivationWeights}:\n          backend_util.FusedConv2DConfig): Tensor4D {\n    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n        (convInfo.padInfo.type === 'SAME' ||\n         convInfo.padInfo.type === 'VALID')) {\n      return this.conv2dByMatMul(\n          input, filter, convInfo, bias, activation, preluActivationWeights);\n    }\n    if (env().getBool('WEBGL_CONV_IM2COL') && input.shape[0] === 1) {\n      return this.conv2dWithIm2Row(\n          input, filter, convInfo, bias, activation, preluActivationWeights);\n    }\n\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const fusedActivation =\n        activation ? mapActivationToShaderProgram(activation, false) : null;\n    const program = new Conv2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n    const inputs: TensorInfo[] = [input, filter];\n    if (bias) {\n      inputs.push(bias);\n    }\n    if (preluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    return this.compileAndRun(program, inputs);\n  }\n\n  conv2d(x: Tensor4D, filter: Tensor4D, convInfo: backend_util.Conv2DInfo):\n      Tensor4D {\n    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n        (convInfo.padInfo.type === 'SAME' ||\n         convInfo.padInfo.type === 'VALID')) {\n      return this.conv2dByMatMul(x, filter, convInfo);\n    }\n    if (env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n      return this.conv2dWithIm2Row(x, filter, convInfo);\n    }\n    const program = new Conv2DProgram(convInfo);\n    return this.compileAndRun(program, [x, filter]);\n  }\n\n  conv2dDerInput(\n      dy: Tensor4D, filter: Tensor4D,\n      convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const program = new Conv2DDerInputProgram(convInfo);\n    return this.compileAndRun(program, [dy, filter]);\n  }\n\n  conv2dDerFilter(x: Tensor4D, dy: Tensor4D, convInfo: backend_util.Conv2DInfo):\n      Tensor4D {\n    const program = new Conv2DDerFilterProgram(convInfo);\n    return this.compileAndRun(program, [x, dy]);\n  }\n\n  fusedDepthwiseConv2D(\n      {input, filter, convInfo, bias, activation, preluActivationWeights}:\n          backend_util.FusedConv2DConfig): Tensor4D {\n    const shouldPackDepthwiseConv = env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n        convInfo.strideWidth <= 2 &&\n        convInfo.outChannels / convInfo.inChannels === 1;\n    const fusedActivation = activation ?\n        mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) :\n        null;\n    const inputs: Tensor[] = [input, filter];\n\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    if (hasBias) {\n      inputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n\n    let program: DepthwiseConv2DProgram|DepthwiseConvPacked2DProgram;\n    if (shouldPackDepthwiseConv) {\n      program = new DepthwiseConvPacked2DProgram(\n          convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n      return this.compileAndRun(program, inputs);\n    }\n\n    program = new DepthwiseConv2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n    return this.compileAndRun(program, inputs);\n  }\n\n  depthwiseConv2D(\n      x: Tensor4D, filter: Tensor4D,\n      convInfo: backend_util.Conv2DInfo): Tensor4D {\n    let program: DepthwiseConv2DProgram|DepthwiseConvPacked2DProgram;\n    if (env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n        convInfo.strideWidth <= 2 &&\n        convInfo.outChannels / convInfo.inChannels === 1) {\n      program = new DepthwiseConvPacked2DProgram(convInfo);\n      return this.compileAndRun(program, [x, filter]);\n    }\n\n    program = new DepthwiseConv2DProgram(convInfo);\n    return this.compileAndRun(program, [x, filter]);\n  }\n\n  depthwiseConv2DDerInput(\n      dy: Tensor4D, filter: Tensor4D,\n      convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const program = new DepthwiseConv2DDerInputProgram(convInfo);\n    return this.compileAndRun(program, [dy, filter]);\n  }\n\n  depthwiseConv2DDerFilter(\n      x: Tensor4D, dy: Tensor4D, convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const program = new DepthwiseConv2DDerFilterProgram(convInfo);\n    return this.compileAndRun(program, [x, dy]);\n  }\n\n  conv3d(x: Tensor5D, filter: Tensor5D, convInfo: backend_util.Conv3DInfo):\n      Tensor5D {\n    const program = new Conv3DProgram(convInfo);\n    return this.compileAndRun(program, [x, filter]);\n  }\n\n  conv3dDerInput(\n      dy: Tensor5D, filter: Tensor5D,\n      convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const program = new Conv3DDerInputProgram(convInfo);\n    return this.compileAndRun(program, [dy, filter]);\n  }\n\n  conv3dDerFilter(x: Tensor5D, dy: Tensor5D, convInfo: backend_util.Conv3DInfo):\n      Tensor5D {\n    const program = new Conv3DDerFilterProgram(convInfo);\n    return this.compileAndRun(program, [x, dy]);\n  }\n\n  unstack(x: Tensor, axis: number): Tensor[] {\n    const num = x.shape[axis];\n    const outShape: number[] = new Array(x.rank - 1);\n    let outIndex = 0;\n    for (let i = 0; i < x.rank; i++) {\n      if (i !== axis) {\n        outShape[outIndex++] = x.shape[i];\n      }\n    }\n\n    const begin = new Array(x.rank).fill(0);\n    const size = x.shape.slice();\n    size[axis] = 1;\n    const res = new Array(num);\n    for (let i = 0; i < res.length; i++) {\n      begin[axis] = i;\n      res[i] = this.slice(x, begin, size).reshape(outShape);\n    }\n    return res;\n  }\n\n  avgPool3d(x: Tensor5D, convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const program = new Pool3DProgram(convInfo, 'avg', false);\n    return this.compileAndRun(program, [x], 'float32');\n  }\n\n  avgPool3dBackprop(\n      dy: Tensor5D, x: Tensor5D, convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const avgPool3dBackpropProgram = new AvgPool3DBackpropProgram(convInfo);\n    return this.compileAndRun(avgPool3dBackpropProgram, [dy], x.dtype);\n  }\n\n  maxPool3d(x: Tensor5D, convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const program = new Pool3DProgram(convInfo, 'max', false);\n    return this.compileAndRun(program, [x], 'float32');\n  }\n\n  maxPool3dBackprop(\n      dy: Tensor5D, x: Tensor5D, y: Tensor5D,\n      convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const getPositions = true;\n    const maxPool3dPositionsProgram =\n        new Pool3DProgram(convInfo, 'max', getPositions);\n    const maxPool3dPositions: Tensor5D =\n        this.compileAndRun(maxPool3dPositionsProgram, [x]);\n    const maxPool3dBackPropProgram = new MaxPool3DBackpropProgram(convInfo);\n    const result = this.compileAndRun(\n        maxPool3dBackPropProgram, [dy, maxPool3dPositions], x.dtype);\n    maxPool3dPositions.dispose();\n    return result as Tensor5D;\n  }\n\n  resizeBilinear(\n      x: Tensor4D, newHeight: number, newWidth: number,\n      alignCorners: boolean): Tensor4D {\n    const program = env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n        new ResizeBilinearPackedProgram(\n            x.shape, newHeight, newWidth, alignCorners) :\n        new ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);\n    return this.compileAndRun(program, [x], 'float32');\n  }\n\n  resizeBilinearBackprop(dy: Tensor4D, x: Tensor4D, alignCorners: boolean):\n      Tensor4D {\n    const program = new ResizeBilinearBackpropProgram(dy, x, alignCorners);\n\n    return this.compileAndRun(program, [dy]);\n  }\n\n  resizeNearestNeighbor(\n      x: Tensor4D, newHeight: number, newWidth: number,\n      alignCorners: boolean): Tensor4D {\n    const program = new ResizeNearestNeighborProgram(\n        x.shape, newHeight, newWidth, alignCorners);\n    return this.compileAndRun(program, [x]);\n  }\n\n  resizeNearestNeighborBackprop(\n      dy: Tensor4D, x: Tensor4D, alignCorners: boolean): Tensor4D {\n    const program =\n        new ResizeNearestNeigborBackpropProgram(dy, x, alignCorners);\n    return this.compileAndRun(program, [dy]);\n  }\n\n  multinomial(\n      logits: Tensor2D, normalized: boolean, numSamples: number,\n      seed: number): Tensor2D {\n    const probs = normalized ? logits : softmax(logits);\n    const batchSize = probs.shape[0];\n    const numOutcomes = probs.shape[1];\n    const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);\n    const customSetup = program.getCustomSetupFunc(seed);\n    return this.compileAndRun(program, [probs], 'int32', customSetup);\n  }\n\n  oneHot(indices: Tensor1D, depth: number, onValue: number, offValue: number):\n      Tensor2D {\n    const program = new OneHotProgram(indices.size, depth, onValue, offValue);\n    return this.compileAndRun(program, [indices]);\n  }\n\n  diag(x: Tensor): Tensor {\n    const program = new DiagProgram(x.size);\n    return this.compileAndRun(program, [x]);\n  }\n\n  cropAndResize(\n      image: Tensor4D, boxes: Tensor2D, boxIndex: Tensor1D,\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number): Tensor4D {\n    const program = new CropAndResizeProgram(\n        image.shape, boxes.shape, cropSize, method, extrapolationValue);\n    return this.compileAndRun(program, [image, boxes, boxIndex], 'float32');\n  }\n\n  depthToSpace(x: Tensor4D, blockSize: number, dataFormat: 'NHWC'|'NCHW'):\n      Tensor4D {\n    util.assert(\n        blockSize > 1,\n        () =>\n            `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n\n    const batchSize = x.shape[0];\n    const inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];\n    const inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];\n    const inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];\n\n    const outputHeight = inputHeight * blockSize;\n    const outputWidth = inputWidth * blockSize;\n    const outputDepth = inputDepth / (blockSize * blockSize);\n\n    const outputShape = (dataFormat === 'NHWC') ?\n        [batchSize, outputHeight, outputWidth, outputDepth] :\n        [batchSize, outputDepth, outputHeight, outputWidth];\n\n    const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);\n    return this.compileAndRun(program, [x]);\n  }\n\n  split<T extends Tensor>(x: T, sizeSplits: number[], axis: number): T[] {\n    return split(x, sizeSplits, axis);\n  }\n\n  scatterND<R extends Rank>(\n      indices: Tensor, updates: Tensor, shape: ShapeMap[R]): Tensor<R> {\n    const {sliceRank, numUpdates, sliceSize, strides, outputSize} =\n        backend_util.calculateShapes(updates, indices, shape);\n\n    const flattenShape = [outputSize / sliceSize, sliceSize];\n    const flattenIndices = indices.reshape([numUpdates, sliceRank]);\n    const flattenX = updates.reshape([numUpdates, sliceSize]);\n\n    if (outputSize === 0) {\n      return backend_util.reshapeTensor(tensor([]), shape);\n    }\n    const defaultValue = scalar(0);\n    const program = new ScatterProgram(\n        numUpdates, sliceRank, flattenIndices.rank, flattenX.rank, strides,\n        flattenShape);\n    const res: Tensor =\n        this.compileAndRun(program, [flattenX, flattenIndices, defaultValue]);\n    return res.reshape(shape);\n  }\n\n  sparseToDense<R extends Rank>(\n      sparseIndices: Tensor, sparseValues: Tensor, outputShape: ShapeMap[R],\n      defaultValue: Scalar): Tensor<R> {\n    const {sliceRank, numUpdates, strides, outputSize} =\n        backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n\n    const sumDupeIndices = false;\n    const program = new ScatterProgram(\n        numUpdates, sliceRank, sparseIndices.rank, sparseValues.rank, strides,\n        [outputSize, 1], sumDupeIndices);\n    const res: Tensor = this.compileAndRun(\n        program, [sparseValues, sparseIndices, defaultValue]);\n    return res.reshape(outputShape);\n  }\n\n  gatherND(x: Tensor, indices: Tensor): Tensor {\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n\n    const [resultShape, numSlices, sliceSize, strides] =\n        backend_util.prepareAndValidate(x, indices);\n\n    const flattenIndices = indices.reshape([numSlices, sliceRank]);\n    const flattenX = x.reshape([x.size / sliceSize, sliceSize]);\n    const program =\n        new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);\n    const res: Tensor = this.compileAndRun(program, [flattenX, flattenIndices]);\n    return res.reshape(resultShape);\n  }\n\n  fill<R extends Rank>(\n      shape: ShapeMap[R], value: number|string, dtype?: DataType): Tensor<R> {\n    dtype = dtype || util.inferDtype(value);\n\n    if (dtype === 'string') {\n      // String type should be handled in CPU memory.\n      const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n      values.fill(value as string);\n      return engine().makeTensor(values, shape, dtype, this) as Tensor<R>;\n    } else {\n      const program = new FillProgram(shape, value as number);\n      const customSetup = program.getCustomSetupFunc(value as number);\n      return this.compileAndRun(program, [], dtype, customSetup);\n    }\n  }\n\n  onesLike<R extends Rank>(x: Tensor<R>): Tensor<R> {\n    if (x.dtype === 'string') {\n      throw new Error('onesLike is not supported under string dtype');\n    } else {\n      // TODO(cais, smilkov): Add WebGL shader for onesLike:\n      //   https://github.com/tensorflow/tfjs/issues/1293\n      return this.fill(x.shape, 1, x.dtype);\n    }\n  }\n\n  zerosLike<R extends Rank>(x: Tensor<R>): Tensor<R> {\n    return this.fill(x.shape, x.dtype === 'string' ? '' : 0, x.dtype);\n  }\n\n  linspace(start: number, stop: number, num: number): Tensor1D {\n    // TODO: Use CPU implementation due to the precision problem in Safari.\n    return backend_util.linspaceImpl(start, stop, num);\n  }\n\n  makeTensorInfo(shape: number[], dtype: DataType, values?: BackendValues):\n      TensorInfo {\n    const dataId = this.write(values, shape, dtype);\n    this.texData.get(dataId).usage = null;\n    return {dataId, shape, dtype};\n  }\n\n  private makeOutput<T extends Tensor>(\n      shape: number[], dtype: DataType, values?: BackendValues): T {\n    const {dataId} = this.makeTensorInfo(shape, dtype, values);\n    return engine().makeTensorFromDataId(dataId, shape, dtype, this) as T;\n  }\n\n  private unpackTensor(input: TensorInfo): TensorInfo {\n    const program = new UnpackProgram(input.shape);\n    return this.runWebGLProgram(program, [input], input.dtype);\n  }\n\n  private packTensor(input: TensorInfo): TensorInfo {\n    const program = new PackProgram(input.shape);\n    const preventEagerUnpackingOutput = true;\n    return this.runWebGLProgram(\n        program, [input], input.dtype, null /* customSetup */,\n        preventEagerUnpackingOutput);\n  }\n\n  private packedReshape(input: TensorInfo, afterShape: number[]): TensorInfo {\n    const input3DShape = [\n      webgl_util.getBatchDim(input.shape),\n      ...webgl_util.getRowsCols(input.shape)\n    ] as [number, number, number];\n    const input3D: TensorInfo = {\n      dtype: input.dtype,\n      shape: input3DShape,\n      dataId: input.dataId\n    };\n    const afterShapeAs3D = [\n      webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n    ] as [number, number, number];\n\n    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    const preventEagerUnpackingOfOutput = true;\n    const output = this.runWebGLProgram(\n        program, [input3D], input.dtype, null /* customSetup */,\n        preventEagerUnpackingOfOutput);\n    return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n  }\n\n  private decode(dataId: DataId): TensorInfo {\n    const texData = this.texData.get(dataId);\n    const {isPacked, shape, dtype} = texData;\n    const shapeAs3D =\n        webgl_util.getShapeAs3D(shape) as [number, number, number];\n    let program;\n    if (isPacked) {\n      program = new DecodeMatrixPackedProgram(shapeAs3D);\n    } else {\n      program = new DecodeMatrixProgram(shapeAs3D);\n    }\n    const preventEagerUnpackingOfOutput = true;\n    const out = this.runWebGLProgram(\n        program, [{shape: shapeAs3D, dtype, dataId}], dtype,\n        null /* customSetup */, preventEagerUnpackingOfOutput);\n    return {dtype, shape, dataId: out.dataId};\n  }\n\n  runWebGLProgram(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype: DataType,\n      customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => void,\n      preventEagerUnpackingOfOutput = false): TensorInfo {\n    const output = this.makeTensorInfo(program.outputShape, outputDtype);\n    const outData = this.texData.get(output.dataId);\n    if (program.packedOutput) {\n      outData.isPacked = true;\n    }\n    if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n      const texelShape = tex_util.getDenseTexShape(program.outputShape);\n      // For a densely packed output, we explicitly set texShape\n      // so it doesn't get assigned later according to our typical packing\n      // scheme wherein a single texel can only contain values from adjacent\n      // rows/cols.\n      outData.texShape = texelShape.map(d => d * 2) as [number, number];\n    }\n    if (program.outTexUsage != null) {\n      outData.usage = program.outTexUsage;\n    }\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      outData.values =\n          util.getTypedArrayFromDType(output.dtype as 'float32', 0);\n      return output;\n    }\n\n    const dataToDispose: TensorInfo[] = [];\n    const inputsData: TensorData[] = inputs.map(input => {\n      if (input.dtype === 'complex64') {\n        throw new Error(\n            `GPGPUProgram does not support complex64 input. For complex64 ` +\n            `dtypes, please separate the program into real and imaginary ` +\n            `parts.`);\n      }\n\n      let texData = this.texData.get(input.dataId);\n\n      if (texData.texture == null) {\n        if (!program.packedInputs &&\n            util.sizeFromShape(input.shape) <=\n                env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n          // Upload small tensors that live on the CPU as uniforms, not as\n          // textures. Do this only when the environment supports 32bit floats\n          // due to problems when comparing 16bit floats with 32bit floats.\n          // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n          // possible for packed shaders to sample from uniforms.\n          return {\n            shape: input.shape,\n            texData: null,\n            isUniform: true,\n            uniformValues: texData.values as TypedArray\n          };\n        }\n\n        // This ensures that if a packed program's inputs have not yet been\n        // uploaded to the GPU, they get uploaded as packed right off the bat.\n        if (program.packedInputs) {\n          texData.isPacked = true;\n          texData.shape = input.shape;\n        }\n      } else if (!!texData.isPacked !== !!program.packedInputs) {\n        input = texData.isPacked ? this.unpackTensor(input) :\n                                   this.packTensor(input);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n      } else if (\n          texData.isPacked &&\n          !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n        // This is a special case where a texture exists for a tensor\n        // but the shapes are incompatible (due to packing constraints) because\n        // the tensor did not have a chance to go through the packed reshape\n        // shader. This only happens when we reshape the *same* tensor to form\n        // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n        // case will disappear once packed uploading is the default.\n\n        const savedInput = input;\n        const targetShape = input.shape;\n\n        input.shape = texData.shape;\n        input = this.packedReshape(input as Tensor, targetShape);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n\n        savedInput.shape = targetShape;\n      }\n\n      this.uploadToGPU(input.dataId);\n      return {shape: input.shape, texData, isUniform: false};\n    });\n\n    this.uploadToGPU(output.dataId);\n    const outputData:\n        TensorData = {shape: output.shape, texData: outData, isUniform: false};\n    const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n    const binary = this.getAndSaveBinary(key, () => {\n      return gpgpu_math.compileProgram(\n          this.gpgpu, program, inputsData, outputData);\n    });\n    const shouldTimeProgram = this.activeTimers != null;\n    let query: WebGLQuery|CPUTimerQuery;\n    if (shouldTimeProgram) {\n      query = this.startTimer();\n    }\n\n    gpgpu_math.runProgram(\n        this.gpgpu, binary, inputsData, outputData, customSetup);\n\n    dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));\n\n    if (shouldTimeProgram) {\n      query = this.endTimer(query);\n      this.activeTimers.push(\n          {name: program.constructor.name, query: this.getQueryTime(query)});\n    }\n\n    if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n        preventEagerUnpackingOfOutput === false) {\n      const unpacked = this.unpackTensor(output);\n      this.disposeIntermediateTensorInfo(output);\n      return unpacked;\n    }\n    return output;\n  }\n\n  compileAndRun<K extends TensorInfo>(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype?: DataType,\n      customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => void,\n      preventEagerUnpackingOfOutput = false): K {\n    outputDtype = outputDtype || inputs[0].dtype;\n    const outInfo = this.runWebGLProgram(\n        program, inputs, outputDtype, customSetup,\n        preventEagerUnpackingOfOutput);\n    return engine().makeTensorFromDataId(\n               outInfo.dataId, outInfo.shape, outInfo.dtype) as {} as K;\n  }\n\n  private getAndSaveBinary(key: string, getBinary: () => GPGPUBinary):\n      GPGPUBinary {\n    if (!(key in this.binaryCache)) {\n      this.binaryCache[key] = getBinary();\n    }\n    return this.binaryCache[key];\n  }\n\n  getTextureManager(): TextureManager {\n    return this.textureManager;\n  }\n\n  private disposed = false;\n\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n    // Avoid disposing the compiled webgl programs during unit testing because\n    // it slows down test execution.\n    if (!env().getBool('IS_TEST')) {\n      const allKeys = Object.keys(this.binaryCache);\n      allKeys.forEach(key => {\n        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n        delete this.binaryCache[key];\n      });\n    }\n    this.textureManager.dispose();\n    if (this.canvas != null &&\n        (typeof (HTMLCanvasElement) !== 'undefined' &&\n         this.canvas instanceof HTMLCanvasElement)) {\n      this.canvas.remove();\n    } else {\n      this.canvas = null;\n    }\n    if (this.gpgpuCreatedLocally) {\n      this.gpgpu.program = null;\n      this.gpgpu.dispose();\n    }\n    this.disposed = true;\n  }\n\n  floatPrecision(): 16|32 {\n    if (this.floatPrecisionValue == null) {\n      this.floatPrecisionValue = tidy(() => {\n        if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n          // Momentarily switching DEBUG flag to false so we don't throw an\n          // error trying to upload a small value.\n          const debugFlag = env().getBool('DEBUG');\n          env().set('DEBUG', false);\n          const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n          env().set('DEBUG', debugFlag);\n\n          if (underflowCheckValue > 0) {\n            return 32;\n          }\n        }\n        return 16;\n      });\n    }\n    return this.floatPrecisionValue;\n  }\n  /** Returns the smallest representable number.  */\n  epsilon(): number {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n\n  private uploadToGPU(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    const {shape, dtype, values, texture, usage, isPacked} = texData;\n\n    if (texture != null) {\n      // Array is already on GPU. No-op.\n      return;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let texShape = texData.texShape;\n    if (texShape == null) {\n      texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n      texData.texShape = texShape;\n    }\n\n    if (values != null) {\n      const shapeAs3D = webgl_util.getShapeAs3D(shape);\n\n      let program;\n      let width = texShape[1], height = texShape[0];\n      const isByteArray = values instanceof Uint8Array;\n\n      if (isPacked) {\n        [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(\n            texShape[0], texShape[1]);\n        program = new EncodeMatrixPackedProgram(\n            shapeAs3D, [height, width], isByteArray);\n      } else {\n        program =\n            new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);\n      }\n\n      const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);\n      if (isByteArray) {\n        this.texData.get(tempDenseInputHandle.dataId).usage =\n            TextureUsage.PIXELS;\n      } else {\n        this.texData.get(tempDenseInputHandle.dataId).usage =\n            TextureUsage.UPLOAD;\n      }\n      this.gpgpu.uploadDenseMatrixToTexture(\n          this.getTexture(tempDenseInputHandle.dataId), width, height,\n          values as TypedArray);\n\n      // We want the output to remain packed regardless of the value of\n      // WEBGL_PACK.\n      const preventEagerUnpacking = true;\n      const encodedOutputTarget = this.runWebGLProgram(\n          program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);\n\n      // Have the original texture assume the identity of the encoded output.\n      const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n      texData.texture = outputTexData.texture;\n      texData.texShape = outputTexData.texShape;\n      texData.isPacked = outputTexData.isPacked;\n      texData.usage = outputTexData.usage;\n\n      this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n      this.texData.delete(encodedOutputTarget.dataId);\n\n      // Once uploaded, don't store the values on cpu.\n      texData.values = null;\n      if (shouldTimeProgram) {\n        this.uploadWaitMs += util.now() - start;\n      }\n    } else {\n      const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n      texData.texture = newTexture;\n    }\n  }\n\n  private convertAndCacheOnCPU(dataId: DataId, float32Values?: Float32Array):\n      TypedArray {\n    const texData = this.texData.get(dataId);\n    const {dtype} = texData;\n\n    this.releaseGPUData(dataId);\n\n    if (float32Values != null) {\n      texData.values = float32ToTypedArray(float32Values, dtype as 'float32');\n    }\n    return texData.values as TypedArray;\n  }\n\n  private acquireTexture(\n      texShape: [number, number], texType: TextureUsage, dtype: DataType,\n      isPacked: boolean): WebGLTexture {\n    this.numBytesInGPU += this.computeBytes(texShape, dtype);\n    if (!this.warnedAboutMemory &&\n        this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n      const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n      this.warnedAboutMemory = true;\n      console.warn(\n          `High memory usage in GPU: ${mb} MB, ` +\n          `most likely due to a memory leak`);\n    }\n    return this.textureManager.acquireTexture(texShape, texType, isPacked);\n  }\n\n  private computeBytes(shape: [number, number], dtype: DataType) {\n    return shape[0] * shape[1] * util.bytesPerElement(dtype);\n  }\n\n  private tryRunOnCpuOrThrow<T extends Tensor>(\n      inputs: TensorInfo[], fn: () => T): T|null {\n    if (this.shouldExecuteOnCPU(inputs)) {\n      try {\n        return fn();\n      } catch (e) {\n        if (env().getBool('IS_TEST')) {\n          throw new Error('CPU forwarding failed');\n        }\n      }\n    }\n    return null;\n  }\n}\n\nfunction float32ToTypedArray<D extends NumericDataType>(\n    a: Float32Array, dtype: D): tf.DataTypeMap[D] {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a as tf.DataTypeMap[D];\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    const result = (dtype === 'int32') ? new Int32Array(a.length) :\n                                         new Uint8Array(a.length);\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n    return result as tf.DataTypeMap[D];\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport * as gpgpu_util from './gpgpu_util';\nimport * as webgl_util from './webgl_util';\n\nexport {MathBackendWebGL, WebGLMemoryInfo, WebGLTimingInfo} from './backend_webgl';\nexport {setWebGLContext} from './canvas_util';\nexport {GPGPUContext} from './gpgpu_context';\nexport {GPGPUProgram} from './gpgpu_math';\n// WebGL specific utils.\nexport {gpgpu_util, webgl_util};\n\n/**\n * Enforce use of half precision textures if available on the platform.\n *\n * @doc {heading: 'Environment', namespace: 'webgl'}\n */\nexport function forceHalfFloat(): void {\n  env().set('WEBGL_FORCE_F16_TEXTURES', true);\n}\n","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// base.ts is the webgl backend without auto kernel registration.\n\nimport {device_util, registerBackend} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from './backend_webgl';\nexport {version as version_webgl} from './version';\n\nif (device_util.isBrowser()) {\n  registerBackend('webgl', () => new MathBackendWebGL(), 2 /* priority */);\n}\n\n// Export webgl utilities\nexport * from './webgl';\n\n// Export forceHalfFlost under webgl namespace for the union bundle.\nimport {forceHalfFloat} from './webgl';\nexport const webgl = {forceHalfFloat};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Identity, IdentityInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function identity(\n    args: {inputs: IdentityInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  backend.incRef(x.dataId);\n\n  return {dataId: x.dataId, shape: x.shape, dtype: x.dtype};\n}\n\nexport const identityConfig: KernelConfig = {\n  kernelName: Identity,\n  backendName: 'webgl',\n  kernelFunc: identity as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Complex, ComplexInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\n/**\n * In WebGL data is stored in GPU textures which can't be efficiently copied, so\n * complex tensors share data with their real and imaginary components. Complex\n * tensors increment the `complexParentRefCount` properties of the underlying\n * data buckets to prevent them from being disposed, as the engine's disposal\n * logic does not account for data sharing by complex tensors.\n *\n * When a complex tensor is disposed, it will explicitly decrease the\n * `complexParentRefCount` properties of its underlying components.\n */\nexport function complex(\n    args: {inputs: ComplexInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {real, imag} = inputs;\n\n  const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n  const complex = backend.texData.get(complexInfo.dataId);\n\n  const realTensorInfo = identity({inputs: {x: real}, backend});\n  const realData = backend.texData.get(realTensorInfo.dataId);\n  realData.complexParentRefCount++;\n\n  const imagTensorInfo = identity({inputs: {x: imag}, backend});\n  const imagData = backend.texData.get(imagTensorInfo.dataId);\n  imagData.complexParentRefCount++;\n\n  complex.complexTensorInfos = {real: realTensorInfo, imag: imagTensorInfo};\n\n  return complexInfo;\n}\n\nexport const complexConfig: KernelConfig = {\n  kernelName: Complex,\n  backendName: 'webgl',\n  kernelFunc: complex as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BinaryInputs, DataType, env, KernelFunc, TypedArray, UnaryInputs, upcastType} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\nimport {complex} from '../kernels/Complex';\nimport {UnaryOpProgram} from '../unaryop_gpu';\n\nimport {SimpleBinaryKernelImplCPU} from './shared';\n\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\n\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\n\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippets Op snippet to create `UnaryOpProgram`.\n */\nexport function unaryKernelFunc(opSnippet: string): KernelFunc {\n  return ({inputs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n    const program = new UnaryOpProgram(x.shape, opSnippet);\n    return webglBackend.runWebGLProgram(program, [x], x.dtype);\n  };\n}\n\ntype BinaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  checkOutOfBounds?: boolean,\n  supportsComplex?: boolean,\n  cpuKernelImpl?: SimpleBinaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc({\n  opSnippet,\n  packedOpSnippet,\n  checkOutOfBounds = false,\n  supportsComplex = false,\n  cpuKernelImpl,\n  dtype\n}: BinaryKernelFuncConfig): KernelFunc {\n  return ({inputs, backend}) => {\n    const {a, b} = inputs as BinaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    if (supportsComplex && a.dtype === 'complex64') {\n      const aData = webglBackend.texData.get(a.dataId);\n      const bData = webglBackend.texData.get(b.dataId);\n\n      const [real, imag] = [\n        [aData.complexTensorInfos.real, bData.complexTensorInfos.real],\n        [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]\n      ].map(complexParts => {\n        const [aPart, bPart] = complexParts;\n\n        const aHandle = {\n          dataId: aPart.dataId,\n          dtype: aPart.dtype,\n          shape: a.shape\n        };\n        const bHandle = {\n          dataId: bPart.dataId,\n          dtype: bPart.dtype,\n          shape: b.shape\n        };\n\n        const program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        return webglBackend.runWebGLProgram(\n            program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n      });\n\n      const complexOutput =\n          complex({inputs: {real, imag}, backend: webglBackend});\n\n      webglBackend.disposeIntermediateTensorInfo(real);\n      webglBackend.disposeIntermediateTensorInfo(imag);\n\n      // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n\n      return complexOutput;\n    }\n\n    const $dtype = dtype || upcastType(a.dtype, b.dtype);\n    if (webglBackend.shouldExecuteOnCPU([a, b]) && cpuKernelImpl != null) {\n      const aData = webglBackend.texData.get(a.dataId);\n      const bData = webglBackend.texData.get(b.dataId);\n      const [outValues, outShape] = cpuKernelImpl(\n          a.shape, b.shape, aData.values as TypedArray,\n          bData.values as TypedArray, $dtype);\n\n      const out = webglBackend.makeTensorInfo(outShape, $dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n      return out;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_BINARY_OPERATIONS') &&\n        packedOpSnippet != null;\n    let program: BinaryOpProgram|BinaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new BinaryOpPackedProgram(\n          packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n    } else {\n      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    }\n\n    return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Add, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {addImplCPU as cpuAdd} from '../kernel_utils/shared';\n\nconst ADD = 'return a + b;';\n\nexport const addKernelFunc = binaryKernelFunc({\n  opSnippet: ADD,\n  packedOpSnippet: ADD,\n  supportsComplex: true,\n  cpuKernelImpl: cpuAdd\n});\n\nexport const addConfig: KernelConfig = {\n  kernelName: Add,\n  backendName: 'webgl',\n  kernelFunc: addKernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Atan2} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc, CHECK_NAN_SNIPPET_BINARY, CHECK_NAN_SNIPPET_BINARY_PACKED} from '../kernel_utils/kernel_funcs_utils';\n\nconst ATAN2 = CHECK_NAN_SNIPPET_BINARY + `\n  return atan(a, b);\n`;\n\nconst ATAN2_PACKED = `\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET_BINARY_PACKED + `\n  return result;\n`;\n\nexport const atan2 =\n    binaryKernelFunc({opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED});\n\nexport const atan2Config: KernelConfig = {\n  kernelName: Atan2,\n  backendName: 'webgl',\n  kernelFunc: atan2,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPool, AvgPoolAttrs, AvgPoolInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\nimport {identity} from './Identity';\n\nexport function avgPool(args: {\n  inputs: AvgPoolInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPoolAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  assertNotComplex(x, 'avgPool');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations = 1;\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in avgPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n      util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return identity({inputs: {x}, backend});\n  }\n  const avgPoolProgram = new Pool2DProgram(convInfo, 'avg', false);\n  return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\n\nexport const avgPoolConfig: KernelConfig = {\n  kernelName: AvgPool,\n  backendName: 'webgl',\n  kernelFunc: avgPool as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPoolBackprop, AvgPoolBackpropAttrs, AvgPoolBackpropInputs, backend_util, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {AvgPool2DBackpropProgram} from '../avg_pool_backprop_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function avgPoolBackprop(args: {\n  inputs: AvgPoolBackpropInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPoolBackpropAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input} = inputs;\n  const x = input;\n  assertNotComplex([dy, input], 'avgPoolBackprop');\n  const {filterSize, strides, pad} = attrs;\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      1 /* dilations */, pad);\n  const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);\n  return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\n\nexport const avgPoolBackpropConfig: KernelConfig = {\n  kernelName: AvgPoolBackprop,\n  backendName: 'webgl',\n  kernelFunc: avgPoolBackprop as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class BatchNormProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null,\n      varianceEpsilon: number) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n\n    let offsetSnippet = '0.0';\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = '1.0';\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    this.outputShape = xShape;\n    this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${offsetSnippet};\n        float scale = ${scaleSnippet};\n        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class BatchNormPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null,\n      varianceEpsilon: number) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n\n    let offsetSnippet = 'vec4(0.0)';\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = 'vec4(1.0)';\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    this.outputShape = xShape;\n    this.userCode = `\n      void main() {\n        vec4 offset = ${offsetSnippet};\n        vec4 scale = ${scaleSnippet};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `;\n  }\n}\n","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, FusedBatchNorm, FusedBatchNormAttrs, FusedBatchNormInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BatchNormProgram} from '../batchnorm_gpu';\nimport {BatchNormPackedProgram} from '../batchnorm_packed_gpu';\n\nexport const batchNorm: (params: {\n  inputs: FusedBatchNormInputs,\n  backend: MathBackendWebGL,\n  attrs: FusedBatchNormAttrs\n}) => TensorInfo = ({inputs, backend, attrs}) => {\n  const {x, mean, variance, offset, scale} = inputs;\n\n  util.assert(\n      mean.shape.length === variance.shape.length,\n      () => 'Batch normalization gradient requires mean and variance to have ' +\n          'equal ranks.');\n  util.assert(\n      offset == null || mean.shape.length === offset.shape.length,\n      () => 'Batch normalization gradient requires mean and offset to have ' +\n          'equal ranks.');\n  util.assert(\n      scale == null || mean.shape.length === scale.shape.length,\n      () => 'Batch normalization gradient requires mean and scale to have ' +\n          'equal ranks.');\n\n  let {varianceEpsilon} = attrs;\n  if (varianceEpsilon == null) {\n    varianceEpsilon = 0.001;\n  }\n\n  const finalInputs = [x, mean, variance];\n\n  let offsetShape = null;\n  if (offset != null) {\n    offsetShape = offset.shape;\n    finalInputs.push(offset);\n  }\n\n  let scaleShape = null;\n  if (scale != null) {\n    scaleShape = scale.shape;\n    finalInputs.push(scale);\n  }\n\n  const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n      new BatchNormPackedProgram(\n          x.shape, mean.shape, variance.shape, offsetShape, scaleShape,\n          varianceEpsilon) :\n      new BatchNormProgram(\n          x.shape, mean.shape, variance.shape, offsetShape, scaleShape,\n          varianceEpsilon);\n  const output =\n      backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);\n\n  return output;\n};\n\nexport const batchNormConfig: KernelConfig = {\n  kernelName: FusedBatchNorm,\n  backendName: 'webgl',\n  kernelFunc: batchNorm as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NotEqual} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst NOT_EQUAL = `return float(a != b);`;\n\nexport const notEqual = binaryKernelFunc({opSnippet: NOT_EQUAL, dtype: 'bool'});\n\nexport const notEqualConfig: KernelConfig = {\n  kernelName: NotEqual,\n  backendName: 'webgl',\n  kernelFunc: notEqual,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Real, RealInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\nexport function real(args: {inputs: RealInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n  const inputData = backend.texData.get(input.dataId);\n\n  return identity({inputs: {x: inputData.complexTensorInfos.real}, backend});\n}\n\nexport const realConfig: KernelConfig = {\n  kernelName: Real,\n  backendName: 'webgl',\n  kernelFunc: real as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport {BinaryInputs, Cast, CastAttrs, CastInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {complex} from './Complex';\nimport {identity} from './Identity';\nimport {notEqual} from './NotEqual';\nimport {real} from './Real';\n\nimport {int} from '../kernel_utils/int';\n\nexport function cast(\n    args: {inputs: CastInputs, backend: MathBackendWebGL, attrs: CastAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {dtype} = attrs;\n\n  // Casting to complex64.\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return identity({inputs: {x}, backend});\n    }\n\n    // TODO(annxingyuan): Import kernel function once zeros is modularized.\n    const zerosTensor = tf.zeros(x.shape);\n    const floatX = cast({inputs: {x}, backend, attrs: {dtype: 'float32'}});\n\n    const result =\n        complex({inputs: {real: floatX, imag: zerosTensor}, backend});\n\n    zerosTensor.dispose();\n    backend.disposeIntermediateTensorInfo(floatX);\n\n    return result;\n  }\n\n  // Casting from complex64\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const result = cast({inputs: {x: realPart}, backend, attrs: {dtype}});\n    backend.disposeIntermediateTensorInfo(realPart);\n    return result;\n  }\n\n  if (!util.hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    const result = identity({inputs: {x}, backend});\n    return {dataId: result.dataId, shape: result.shape, dtype};\n  }\n\n  if (dtype === 'int32') {\n    return int(x, backend);\n  }\n\n  if (dtype === 'bool') {\n    const zerosTensorInfo = backend.makeTensorInfo(\n        [], 'bool', util.getTypedArrayFromDType('bool', 1));\n\n    const binaryInputs: BinaryInputs = {a: x, b: zerosTensorInfo};\n\n    const result = notEqual({inputs: binaryInputs, backend}) as TensorInfo;\n    backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n    return result;\n  }\n\n  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\n\nexport const castConfig: KernelConfig = {\n  kernelName: Cast,\n  backendName: 'webgl',\n  kernelFunc: cast as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {UnaryOpProgram} from '../unaryop_gpu';\n\nconst TO_INT = `return float(int(x));`;\n\nexport function int(input: TensorInfo, backend: MathBackendWebGL): TensorInfo {\n  const program = new UnaryOpProgram(input.shape, TO_INT);\n  const output = backend.runWebGLProgram(program, [input], 'int32');\n  return {dataId: output.dataId, shape: output.shape, dtype: output.dtype};\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ConcatProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n  constructor(shapes: Array<[number, number]>) {\n    this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][1];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][1];\n    }\n\n    const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      snippets.push(\n          `else if (yC < ${offsets[i]}) ` +\n          `setOutput(getT${i}(yR, yC-${shift}));`);\n    }\n    const lastIndex = offsets.length;\n    const lastShift = offsets[offsets.length - 1];\n    snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ConcatPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(shapes: number[][], axis: number) {\n    this.outputShape = backend_util.computeOutShape(shapes, axis);\n    const shape = this.outputShape;\n    const rank = shape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][axis];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][axis];\n    }\n\n    const channel = channels[axis];\n    const lastChannels = channels.slice(-2);\n    const allChannels = channels.join();\n\n    let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      // Note: the >= comparison below may seem unnecessary given the check\n      // above but is needed to workaround branch execution issues on some\n      // devices. It makes all the conditions exclusive without relying on\n      // execution order.\n      getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n    }\n    const lastIndex = offsets.length;\n    const shift = offsets[offsets.length - 1];\n    getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n\n    this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n  }\n}\n\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels: string[], channel: string, shift: number) {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Imag, ImagInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\nexport function imag(args: {inputs: ImagInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n  const inputData = backend.texData.get(input.dataId);\n\n  return identity({inputs: {x: inputData.complexTensorInfos.imag}, backend});\n}\n\nexport const imagConfig: KernelConfig = {\n  kernelName: Imag,\n  backendName: 'webgl',\n  kernelFunc: imag as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Reshape, ReshapeAttrs, ReshapeInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {packedReshape} from '../kernel_utils/reshape';\nimport {isReshapeFree} from '../webgl_util';\n\nexport function reshape(args: {\n  inputs: ReshapeInputs,\n  backend: MathBackendWebGL,\n  attrs: ReshapeAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {shape} = attrs;\n  const webglBackend = backend;\n\n  const xSize = util.sizeFromShape(x.shape);\n  const $shape = util.inferFromImplicitShape(shape, xSize);\n  const $xSize = util.sizeFromShape($shape);\n\n  util.assert(\n      xSize === $xSize,\n      () => `The new shape (${$shape}) has ${$xSize} elements and the old ` +\n          `shape (${x.shape}) has ${xSize} elements. The new shape and old ` +\n          `shape must have the same number of elements.`);\n\n  const xTexData = webglBackend.texData.get(x.dataId);\n  if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) &&\n      !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {\n    return packedReshape(x, $shape, webglBackend);\n  }\n\n  webglBackend.incRef(x.dataId);\n\n  return {dataId: x.dataId, shape: $shape, dtype: x.dtype};\n}\n\nexport const reshapeConfig: KernelConfig = {\n  kernelName: Reshape,\n  backendName: 'webgl',\n  kernelFunc: reshape as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ReshapePackedProgram} from '../reshape_packed_gpu';\nimport {getBatchDim, getRowsCols} from '../webgl_util';\n\nexport function packedReshape(\n    input: TensorInfo, afterShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const input3DShape =\n      [getBatchDim(input.shape),\n       ...getRowsCols(input.shape)] as [number, number, number];\n  const input3D: TensorInfo = {\n    dtype: input.dtype,\n    shape: input3DShape,\n    dataId: input.dataId\n  };\n  const afterShapeAs3D =\n      [getBatchDim(afterShape),\n       ...getRowsCols(afterShape)] as [number, number, number];\n\n  const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n  const preventEagerUnpackingOfOutput = true;\n  const output = backend.runWebGLProgram(\n      program, [input3D], input.dtype, null /* customSetup */,\n      preventEagerUnpackingOfOutput);\n  return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Concat, ConcatAttrs, ConcatInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {concatImpl} from './Concat_impl';\n\nexport function concat(\n    args:\n        {inputs: ConcatInputs, attrs: ConcatAttrs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n  const outShape =\n      backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n\n  if (util.sizeFromShape(outShape) === 0) {\n    return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n  }\n\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n  if ($inputs.length === 1) {\n    return $inputs[0];\n  }\n\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, $axis);\n\n  return concatImpl($inputs, $axis, backend);\n}\n\nexport const concatConfig: KernelConfig = {\n  kernelName: Concat,\n  backendName: 'webgl',\n  kernelFunc: concat as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, ConcatInputs, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ConcatProgram} from '../concat_gpu';\nimport {ConcatPackedProgram} from '../concat_packed_gpu';\n\nimport {complex} from './Complex';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {reshape} from './Reshape';\n\nexport function concatImpl(\n    inputs: ConcatInputs, axis: number, backend: MathBackendWebGL): TensorInfo {\n  const dtype = inputs[0].dtype;\n  if (dtype === 'complex64') {\n    const reals = inputs.map((t) => real({inputs: {input: t}, backend}));\n    const imags = inputs.map((t) => imag({inputs: {input: t}, backend}));\n\n    const realConcated = concatImpl(reals, axis, backend);\n    const imagConcated = concatImpl(imags, axis, backend);\n\n    const result =\n        complex({inputs: {real: realConcated, imag: imagConcated}, backend});\n\n    reals.forEach(r => backend.disposeIntermediateTensorInfo(r));\n    imags.forEach(i => backend.disposeIntermediateTensorInfo(i));\n    backend.disposeIntermediateTensorInfo(realConcated);\n    backend.disposeIntermediateTensorInfo(imagConcated);\n\n    return result;\n  }\n\n  if (inputs.length > env().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n    const midIndex = Math.floor(inputs.length / 2);\n    const leftSide = concatImpl(inputs.slice(0, midIndex), axis, backend);\n    const rightSide = concatImpl(inputs.slice(midIndex), axis, backend);\n\n    const result = concatImpl([leftSide, rightSide], axis, backend);\n\n    backend.disposeIntermediateTensorInfo(leftSide);\n    backend.disposeIntermediateTensorInfo(rightSide);\n\n    return result;\n  }\n\n  if (env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') &&\n      inputs[0].shape.length > 1) {\n    const program = new ConcatPackedProgram(inputs.map(t => t.shape), axis);\n    return backend.runWebGLProgram(program, inputs, dtype);\n  }\n\n  // Any concat of n-dimensional tensors across any axis can be reduced to\n  // a concatenation of two-dimensional tensors across the axis 1 by first\n  // partitioning the axes of the original tensors into those less than the\n  // axis to be concatenated and the rest. Then reshape the tensors\n  // into a two-dimensional tensor by collapsing these two sets of axes and\n  // concatenate the resulting matrices across the axis 1, finally reshaping\n  // the result to have the proper shape.\n  const outShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n  const tensors2D = inputs.map(\n      x => reshape({\n        inputs: {x},\n        attrs: {shape: [-1, util.sizeFromShape(x.shape.slice(axis))]},\n        backend\n      }));\n  const program =\n      new ConcatProgram(tensors2D.map(t => t.shape as [number, number]));\n  const result = backend.runWebGLProgram(program, tensors2D, dtype);\n\n  tensors2D.forEach(r => backend.disposeIntermediateTensorInfo(r));\n  const reshapedResult =\n      reshape({inputs: {x: result}, attrs: {shape: outShape}, backend});\n  backend.disposeIntermediateTensorInfo(result);\n\n  return reshapedResult;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Cos, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst COS = CHECK_NAN_SNIPPET_UNARY + `\n  return cos(x);\n`;\n\nexport const cos = unaryKernelFunc(COS);\n\nexport const cosConfig: KernelConfig = {\n  kernelName: Cos,\n  backendName: 'webgl',\n  kernelFunc: cos,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Div} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\n// Without the equality check div produces 0.9999 for a = b, which when\n// floored can cause errors.\nconst DIV = `\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`;\n\n// We do the same as in ./binaryop_gpu, with vec4 and ivec4.\n// On Linux, the vectorized implementation produces NaNs when a and b are 0.\nconst DIV_PACKED = `\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`;\n\nexport const div = binaryKernelFunc(\n    {opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true});\n\nexport const divConfig: KernelConfig = {\n  kernelName: Div,\n  backendName: 'webgl',\n  kernelFunc: div,\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FFTProgram implements GPGPUProgram {\n  variableNames = ['real', 'imag'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      component: 'real'|'imag', inputShape: [number, number],\n      inverse: boolean) {\n    const innerDim = inputShape[1];\n    this.outputShape = inputShape;\n\n    const exponentMultiplierSnippet =\n        inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;\n    const resultDenominator = inverse ? `${innerDim}.0` : '1.0';\n\n    let opString: string;\n    if (component === 'real') {\n      opString = 'return real * expR - imag * expI;';\n    } else if (component === 'imag') {\n      opString = 'return real * expI + imag * expR;';\n    } else {\n      throw new Error(\n          `FFT component must be either \"real\" or \"imag\", got ${component}.`);\n    }\n\n    this.userCode = `\n      const float exponentMultiplier = ${exponentMultiplierSnippet};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${opString}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${innerDim});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${innerDim}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {FFTProgram} from '../fft_gpu';\n\nimport {complex} from './Complex';\nimport {reshape} from './Reshape';\n\nexport function fftImpl(\n    x: TensorInfo, inverse: boolean, backend: MathBackendWebGL): TensorInfo {\n  const xData = backend.texData.get(x.dataId);\n\n  const inputSize = util.sizeFromShape(x.shape);\n  // Collapse all outer dimensions to a single batch dimension.\n  const innerDimensionSize = x.shape[x.shape.length - 1];\n  const batch = inputSize / innerDimensionSize;\n\n  const input2D = reshape(\n      {inputs: {x}, backend, attrs: {shape: [batch, innerDimensionSize]}});\n\n  const xShape = input2D.shape as [number, number];\n  const realProgram = new FFTProgram('real', xShape, inverse);\n  const imagProgram = new FFTProgram('imag', xShape, inverse);\n\n  const inputs = [\n    {\n      dataId: xData.complexTensorInfos.real.dataId,\n      dtype: xData.complexTensorInfos.real.dtype,\n      shape: xShape\n    },\n    {\n      dataId: xData.complexTensorInfos.imag.dataId,\n      dtype: xData.complexTensorInfos.imag.dtype,\n      shape: xShape\n    }\n  ];\n\n  const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n  const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n\n  const complexOutput =\n      complex({inputs: {real: realPart, imag: imagPart}, backend});\n\n  backend.disposeIntermediateTensorInfo(realPart);\n  backend.disposeIntermediateTensorInfo(imagPart);\n\n  const complexOutputReshaped =\n      reshape({inputs: {x: complexOutput}, backend, attrs: {shape: x.shape}});\n\n  backend.disposeIntermediateTensorInfo(complexOutputReshaped);\n\n  return complexOutputReshaped;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {FFT, FFTInputs, KernelConfig, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {fftImpl} from './FFT_impl';\n\nexport function fft(args: {inputs: FFTInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n\n  return fftImpl(input, false /* inverse */, backend);\n}\n\nexport const fftConfig: KernelConfig = {\n  kernelName: FFT,\n  backendName: 'webgl',\n  kernelFunc: fft\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FlipLeftRightProgram implements GPGPUProgram {\n  variableNames = ['Image'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(imageShape: [number, number, number, number]) {\n    const imageWidth = imageShape[2];\n    this.outputShape = imageShape;\n\n    this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${imageWidth} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${imageWidth}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tensor4D} from '@tensorflow/tfjs-core';\nimport {FlipLeftRight, FlipLeftRightInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {FlipLeftRightProgram} from '../flip_left_right_gpu';\n\nexport const flipLeftRightConfig: KernelConfig = {\n  kernelName: FlipLeftRight,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend}) => {\n    const {image} = inputs as FlipLeftRightInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const program = new FlipLeftRightProgram((image as Tensor4D).shape);\n    const output = webglBackend.runWebGLProgram(program, [image], image.dtype);\n    return output;\n  }\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from '../../glsl_version';\nimport {GPGPUProgram} from '../../gpgpu_math';\n\nexport class FromPixelsProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    const [height, width, ] = outputShape;\n    this.outputShape = outputShape;\n    this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);\n\n        vec4 values = ${glsl.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from '../../glsl_version';\nimport {GPGPUProgram} from '../../gpgpu_math';\n\nexport class FromPixelsPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    const [height, width, ] = outputShape;\n    this.outputShape = outputShape;\n    this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${width}.0, ${height}.0);\n            vec4 values = ${glsl.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\nimport {FromPixels, FromPixelsAttrs, FromPixelsInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {TextureUsage} from '../tex_util';\n\nimport {FromPixelsProgram} from './FromPixels_utils/from_pixels_gpu';\nimport {FromPixelsPackedProgram} from './FromPixels_utils/from_pixels_packed_gpu';\n\nexport const fromPixelsConfig: KernelConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgl',\n  kernelFunc: fromPixels as {} as KernelFunc,\n};\n\nlet fromPixels2DContext: CanvasRenderingContext2D;\n\nfunction fromPixels(args: {\n  inputs: FromPixelsInputs,\n  backend: MathBackendWebGL,\n  attrs: FromPixelsAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  let {pixels} = inputs;\n  const {numChannels} = attrs;\n\n  const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n      pixels instanceof HTMLVideoElement;\n  const isImage = typeof (HTMLImageElement) !== 'undefined' &&\n      pixels instanceof HTMLImageElement;\n  const [width, height] = isVideo ?\n      [\n        (pixels as HTMLVideoElement).videoWidth,\n        (pixels as HTMLVideoElement).videoHeight\n      ] :\n      [pixels.width, pixels.height];\n\n  const texShape: [number, number] = [height, width];\n  const outShape = [height, width, numChannels];\n\n  if (isImage || isVideo) {\n    if (fromPixels2DContext == null) {\n      fromPixels2DContext = document.createElement('canvas').getContext('2d');\n    }\n\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(\n        pixels as HTMLVideoElement | HTMLImageElement, 0, 0, width, height);\n    pixels = fromPixels2DContext.canvas;\n  }\n\n  const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\n  // This is a byte texture with pixels.\n  backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n  backend.gpgpu.uploadPixelDataToTexture(\n      backend.getTexture(tempPixelHandle.dataId), pixels as ImageData);\n  const program = env().getBool('WEBGL_PACK') ?\n      new FromPixelsPackedProgram(outShape) :\n      new FromPixelsProgram(outShape);\n  const res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n  backend.disposeData(tempPixelHandle.dataId);\n  return res;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IFFT, IFFTInputs, KernelConfig, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {fftImpl} from './FFT_impl';\n\nexport function ifft(args: {inputs: IFFTInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n\n  return fftImpl(input, true /* inverse */, backend);\n}\n\nexport const ifftConfig: KernelConfig = {\n  kernelName: IFFT,\n  backendName: 'webgl',\n  kernelFunc: ifft\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MeanProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(reduceInfo: backend_util.ReduceInfo, divisor?: number) {\n    const {windowSize, batchSize, inSize, outSize} = reduceInfo;\n    this.outputShape = [batchSize, outSize];\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    let updateSnippet = `sumValue += dot(values, ones);`;\n    if (divisor != null) {\n      const denominator = 1 / divisor;\n      updateSnippet = `sumValue += dot(values * ${\n          util.isInt(denominator) ? denominator.toPrecision(2) :\n                                    denominator}, ones);`;\n    }\n\n    let checkOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return 0.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${updateSnippet}\n        }\n        setOutput(sumValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MeanProgram} from '../mean_gpu';\nimport {ReduceProgram} from '../reduce_gpu';\n\ntype ReduceTypes = 'all'|'any'|'max'|'min'|'sum'|'prod'|'mean';\n\n// Returns an array of configuration objects that describe each stage of the\n// reduction.\nfunction getReductionStages(inShape: number[]):\n    Array<{inSize: number, windowSize: number, outSize: number}> {\n  const stages = [];\n\n  while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {\n    const outSize: number =\n        stages.length ? stages[stages.length - 1].outSize : inShape[1];\n    const windowSize = backend_util.computeOptimalWindowSize(outSize);\n    stages.push({\n      inSize: outSize,\n      windowSize,\n      outSize: Math.ceil(outSize / windowSize)\n    });\n  }\n\n  return stages;\n}\n\nexport function reduce(\n    x: TensorInfo, dtype: DataType, reductionType: ReduceTypes,\n    backend: MathBackendWebGL): TensorInfo {\n  const reductionStages = getReductionStages(x.shape);\n\n  let result = x;\n  for (let i = 0; i < reductionStages.length; i++) {\n    const {inSize, windowSize, outSize} = reductionStages[i];\n\n    let program: ReduceProgram|MeanProgram;\n    let previousResult: TensorInfo;\n    if (reductionType === 'mean') {\n      program = i === 0 ?\n          new MeanProgram(\n              {windowSize, inSize, batchSize: x.shape[0], outSize}, inSize) :\n          new MeanProgram({windowSize, inSize, batchSize: x.shape[0], outSize});\n    } else {\n      program = new ReduceProgram(\n          {windowSize, inSize, batchSize: x.shape[0], outSize}, reductionType);\n    }\n\n    previousResult = result;\n    result = backend.runWebGLProgram(program, [result], dtype);\n\n    if (previousResult.dataId !== x.dataId) {\n      backend.disposeIntermediateTensorInfo(previousResult);\n    }\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TransposeProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const switched = getSwitchedCoords(newDim);\n\n    this.userCode = `\n    void main() {\n      ${dtype} resRC = getOutputCoords();\n      setOutput(getA(${switched}));\n    }\n    `;\n  }\n}\n\nfunction getSwitchedCoords(newDim: number[]): string {\n  const rank = newDim.length;\n  if (rank > 6) {\n    throw Error(`Transpose for rank ${rank} is not yet supported`);\n  }\n  const originalOrder =\n      ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];\n  const switchedCoords = new Array(rank);\n  for (let i = 0; i < newDim.length; i++) {\n    switchedCoords[newDim[i]] = originalOrder[i];\n  }\n  return switchedCoords.join();\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getVecChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TransposePackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    if (this.rank > 6) {\n      throw Error(\n          `Packed transpose for rank ${this.rank} is not yet supported.`);\n    }\n    const dtype = getCoordsDataType(this.rank);\n\n    const outputOrder = getVecChannels('rc', this.rank);\n    const switchedOrder = new Array(this.rank);\n    for (let i = 0; i < newDim.length; i++) {\n      switchedOrder[newDim[i]] = outputOrder[i];\n    }\n    const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;\n    const nextColumn =\n        `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;\n    const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;\n\n    this.userCode = `\n    void main() {\n      ${dtype} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${getc};\n      if(${nextColumn}) {\n        result[1] = ${getc};\n      }\n      --${outputOrder[this.rank - 1]};\n      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {\n        result[2] = ${getc};\n        if(${nextColumn}) {\n          result[3] = ${getc};\n        }\n      }\n      setOutput(result);\n    }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {transposeImplCPU} from '../kernel_utils/shared';\nimport {TransposeProgram} from '../transpose_gpu';\nimport {TransposePackedProgram} from '../transpose_packed_gpu';\n\nexport function transposeImpl(\n    x: TensorInfo, perm: number[], backend: MathBackendWebGL): TensorInfo {\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new TransposePackedProgram(x.shape, perm) :\n      new TransposeProgram(x.shape, perm);\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport {transposeImplCPU};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Max, MaxAttrs, MaxInputs} from '@tensorflow/tfjs-core';\nimport {backend_util, KernelConfig, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {maxImplCPU} from '../kernel_utils/shared';\n\nimport {maxImpl} from './Max_impl';\nimport {transposeImpl, transposeImplCPU} from './Transpose_impl';\n\nexport const maxConfig: KernelConfig = {\n  kernelName: Max,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MaxInputs;\n    const {reductionIndices, keepDims} = attrs as {} as MaxAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const xRank = x.shape.length;\n\n    const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    const maxInputIsTransposed = permutedAxes != null;\n    const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n\n    let maxInput = x;\n    if (maxInputIsTransposed) {\n      if (shouldExecuteOnCPU) {\n        const xTexData = webglBackend.texData.get(maxInput.dataId);\n        const values = xTexData.values as TypedArray;\n\n        const newShape: number[] = new Array(xRank);\n        for (let i = 0; i < newShape.length; i++) {\n          newShape[i] = x.shape[permutedAxes[i]];\n        }\n        const maxInputValues =\n            transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n\n        maxInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n        const maxInputData = webglBackend.texData.get(maxInput.dataId);\n        maxInputData.values = maxInputValues;\n      } else {\n        maxInput = transposeImpl(x, permutedAxes, webglBackend);\n      }\n\n      axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n\n    backend_util.assertAxesAreInnerMostDims('max', axes, xRank);\n    const [maxOutShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(maxInput.shape, axes);\n\n    let outShape = maxOutShape;\n    if (keepDims) {\n      // rather than reshape at the end, set the target shape here.\n      outShape = backend_util.expandShapeToKeepDim(maxOutShape, origAxes);\n    }\n\n    let out;\n    if (shouldExecuteOnCPU) {\n      const xTexData = webglBackend.texData.get(maxInput.dataId);\n      const values = xTexData.values as TypedArray;\n\n      const outValues = maxImplCPU(\n          values, util.sizeFromShape(reduceShape), outShape, x.dtype);\n\n      out = webglBackend.makeTensorInfo(outShape, x.dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n    } else {\n      out = maxImpl(maxInput, reduceShape, outShape, webglBackend);\n    }\n\n    if (maxInputIsTransposed) {\n      webglBackend.disposeIntermediateTensorInfo(maxInput);\n    }\n\n    return out;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from '../kernels/Reshape';\n\nexport function maxImpl(\n    x: TensorInfo, reduceShape: number[], outShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput =\n      reshape({inputs: {x}, attrs: {shape: [batchSize, inSize]}, backend});\n\n  const reduced = reduce(reshapedInput, x.dtype, 'max', backend);\n  const reshapedOutput =\n      reshape({inputs: {x: reduced}, attrs: {shape: outShape}, backend});\n\n  backend.disposeIntermediateTensorInfo(reshapedInput);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  return reshapedOutput;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPool, MaxPoolAttrs, MaxPoolInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\nimport {identity} from './Identity';\n\nexport function maxPool(args: {\n  inputs: MaxPoolInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPoolAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  assertNotComplex(x, 'maxPool');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations = 1;\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n      util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return identity({inputs: {x}, backend});\n  }\n  const maxPoolProgram = new Pool2DProgram(convInfo, 'max', false);\n  return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\n\nexport const maxPoolConfig: KernelConfig = {\n  kernelName: MaxPool,\n  backendName: 'webgl',\n  kernelFunc: maxPool as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPoolBackprop, MaxPoolBackpropAttrs, MaxPoolBackpropInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MaxPool2DBackpropProgram} from '../max_pool_backprop_gpu';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function maxPoolBackprop(args: {\n  inputs: MaxPoolBackpropInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPoolBackpropAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input, output} = inputs;\n  const x = input;\n  assertNotComplex([input, output], 'maxPoolBackprop');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      1 /* dilations */, pad, dimRoundingMode);\n  const getPositions = true;\n  const maxPoolPositionsProgram =\n      new Pool2DProgram(convInfo, 'max', getPositions);\n  const maxPoolPositions: TensorInfo =\n      backend.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);\n\n  const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);\n  const result = backend.runWebGLProgram(\n      maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);\n  backend.disposeIntermediateTensorInfo(maxPoolPositions);\n  return result;\n}\n\nexport const maxPoolBackpropConfig: KernelConfig = {\n  kernelName: MaxPoolBackprop,\n  backendName: 'webgl',\n  kernelFunc: maxPoolBackprop as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {MaxPoolWithArgmax, MaxPoolWithArgmaxAttrs, MaxPoolWithArgmaxInputs} from '@tensorflow/tfjs-core';\nimport {backend_util, KernelConfig, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {maxPoolWithArgmaxImpl} from './MaxPoolWithArgmax_impl';\n\nexport const maxPoolWithArgmaxConfig: KernelConfig = {\n  kernelName: MaxPoolWithArgmax,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MaxPoolWithArgmaxInputs;\n    const {filterSize, strides, pad, includeBatchInIndex} =\n        attrs as {} as MaxPoolWithArgmaxAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    util.assert(\n        x.shape.length === 4,\n        () => `Error in maxPool: input must be rank 4 but got rank ${\n            x.shape.length}.`);\n    const dilations: [number, number] = [1, 1];\n    util.assert(\n        backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n        () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n            `Got strides ${strides} and dilations '${dilations}'`);\n\n    const convInfo = backend_util.computePool2DInfo(\n        x.shape as [number, number, number, number], filterSize, strides,\n        dilations, pad);\n\n    const [result, indexes] =\n        maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, webglBackend);\n    return [result, indexes];\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\n\nexport function maxPoolWithArgmaxImpl(\n    x: TensorInfo, includeBatchInIndex: boolean,\n    convInfo: backend_util.Conv2DInfo,\n    backend: MathBackendWebGL): TensorInfo[] {\n  let program = new Pool2DProgram(convInfo, 'max', false);\n  const poolOutput = backend.runWebGLProgram(program, [x], 'float32');\n\n  program = new Pool2DProgram(convInfo, 'max', true, true, includeBatchInIndex);\n  const indexOutput = backend.runWebGLProgram(program, [x], 'float32');\n  return [poolOutput, indexOutput];\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, Mean, MeanAttrs, MeanInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {meanImpl} from './Mean_impl';\nimport {transposeImpl, transposeImplCPU} from './Transpose_impl';\n\nexport const meanConfig: KernelConfig = {\n  kernelName: Mean,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MeanInputs;\n    const {keepDims, axis} = attrs as {} as MeanAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(axis, x.shape);\n\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    const meanInputIsTransposed = permutedAxes != null;\n    const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n\n    const intermediates: TensorInfo[] = [];\n\n    let meanInput = x;\n    if (meanInputIsTransposed) {\n      if (shouldExecuteOnCPU) {\n        const xTexData = webglBackend.texData.get(meanInput.dataId);\n        const values = xTexData.values as TypedArray;\n\n        const newShape: number[] = new Array(xRank);\n        for (let i = 0; i < newShape.length; i++) {\n          newShape[i] = x.shape[permutedAxes[i]];\n        }\n        const meanInputValues =\n            transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n\n        meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n        const meanInputData = webglBackend.texData.get(meanInput.dataId);\n        meanInputData.values = meanInputValues;\n      } else {\n        meanInput = transposeImpl(x, permutedAxes, webglBackend);\n      }\n\n      intermediates.push(meanInput);\n      axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n\n    backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n    const [meanOutShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(meanInput.shape, axes);\n\n    let outShape = meanOutShape;\n    if (keepDims) {\n      // rather than reshape at the end, set the target shape here.\n      outShape = backend_util.expandShapeToKeepDim(meanOutShape, origAxes);\n    }\n\n    const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);\n    for (const i of intermediates) {\n      webglBackend.disposeIntermediateTensorInfo(i);\n    }\n\n    return out;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from '../kernels/Reshape';\n\nexport function meanImpl(\n    x: TensorInfo, reduceShape: number[], outShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput =\n      reshape({inputs: {x}, attrs: {shape: [batchSize, inSize]}, backend});\n\n  const reduced = reduce(reshapedInput, 'float32', 'mean', backend);\n  const reshapedOutput =\n      reshape({inputs: {x: reduced}, attrs: {shape: outShape}, backend});\n\n  backend.disposeIntermediateTensorInfo(reshapedInput);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  return reshapedOutput;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class MirrorPadProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      mode: 'reflect'|'symmetric') {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const unpackedCoords =\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n    const offset = mode === 'reflect' ? 0 : 1;\n\n    if (rank === 1) {\n      this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${offset};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${offset};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;\n      return;\n    }\n    this.userCode = `\n      ${dtype} start = ${dtype}(${start});\n      ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outC = getOutputCoords();\n        for (int i = 0; i < ${rank}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${offset};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};\n          }\n        }\n        ${dtype} coords = outC - start;\n        setOutput(getX(${unpackedCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\nexport class MirrorPadPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      mode: 'reflect'|'symmetric') {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const coords = getChannels('rc', rank);\n    const source = getChannels('source', rank);\n    const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n    const innerDims =\n        rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n    const offset = mode === 'reflect' ? 0 : 1;\n\n    let mainLoop = '';\n    if (rank === 1) {\n      const padSetup = `\n        ${dtype} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${offset};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${offset};\n        }\n        source -= start;\n      `;\n      mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n    } else {\n      const padSetup = `\n        ${dtype} source = rc;\n        ${dtype} lt = ${dtype}(lessThan(source, start));\n        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));\n        ${dtype} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${offset}) +\n                gte * ((end - 1) * 2 - source + ${offset});\n        source -= start;\n      `;\n\n      mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n        rc = outputLoc;\n        ${coords[rank - 2]} += 1;\n        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {\n          ${padSetup}\n          result[2] = getChannel(getX(${source.join()}), ${innerDims});\n          ${coords[rank - 1]} += 1;\n          if(${cLimit}) {\n            ${padSetup}\n            result[3] = getChannel(getX(${source.join()}), ${innerDims});\n          }\n        }\n      `;\n    }\n\n    this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, MirrorPad, MirrorPadAttrs, MirrorPadInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MirrorPadProgram} from '../mirror_pad_gpu';\nimport {MirrorPadPackedProgram} from '../mirror_pad_packed_gpu';\n\nexport const mirrorPadKernelFunc: (params: {\n  inputs: MirrorPadInputs,\n  backend: MathBackendWebGL,\n  attrs: MirrorPadAttrs\n}) => TensorInfo = ({inputs, backend, attrs}) => {\n  const {x} = inputs;\n  const {paddings, mode} = attrs;\n\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new MirrorPadPackedProgram(x.shape, paddings, mode) :\n      new MirrorPadProgram(x.shape, paddings, mode);\n\n  const output = backend.runWebGLProgram(program, [x], x.dtype);\n\n  return output;\n};\n\nexport const mirrorPadConfig: KernelConfig = {\n  kernelName: MirrorPad,\n  backendName: 'webgl',\n  kernelFunc: mirrorPadKernelFunc as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nexport const COMPLEX_MULTIPLY = {\n  REAL: 'return areal * breal - aimag * bimag;',\n  IMAG: 'return areal * bimag + aimag * breal;'\n};\n\nexport class BinaryOpComplexProgram implements GPGPUProgram {\n  variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(op: string, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n\n    this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${op}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, env, KernelConfig, Multiply, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport * as binaryop_complex_gpu from '../binaryop_complex_gpu';\nimport {BinaryOpComplexProgram} from '../binaryop_complex_gpu';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\nimport {multiplyImplCPU as cpuMultiply} from '../kernel_utils/shared';\n\nimport {complex} from './Complex';\n\nconst MUL = 'return a * b;';\n\nexport function multiply(\n    args: {inputs: BinaryInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {a, b} = inputs;\n  const dtype = backend_util.upcastType(a.dtype, b.dtype);\n\n  if (a.dtype === 'complex64') {\n    const aData = backend.texData.get(a.dataId);\n    const bData = backend.texData.get(b.dataId);\n\n    const realProgram = new BinaryOpComplexProgram(\n        binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);\n    const imagProgram = new BinaryOpComplexProgram(\n        binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);\n\n    const inputs = [\n      {\n        dataId: aData.complexTensorInfos.real.dataId,\n        dtype: aData.complexTensorInfos.real.dtype,\n        shape: a.shape\n      },\n      {\n        dataId: aData.complexTensorInfos.imag.dataId,\n        dtype: aData.complexTensorInfos.imag.dtype,\n        shape: a.shape\n      },\n      {\n        dataId: bData.complexTensorInfos.real.dataId,\n        dtype: bData.complexTensorInfos.real.dtype,\n        shape: b.shape\n      },\n      {\n        dataId: bData.complexTensorInfos.imag.dataId,\n        dtype: bData.complexTensorInfos.imag.dtype,\n        shape: b.shape\n      }\n    ];\n\n    const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n    const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n\n    const complexOutput =\n        complex({inputs: {real: realPart, imag: imagPart}, backend});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(imagPart);\n\n    // TODO(annxingyuan): CPU forwarding for complex inputs.\n    return complexOutput;\n  }\n\n  if (backend.shouldExecuteOnCPU([a, b])) {\n    const aData = backend.texData.get(a.dataId);\n    const bData = backend.texData.get(b.dataId);\n    const [outValues, outShape] = cpuMultiply(\n        a.shape, b.shape, aData.values as TypedArray,\n        bData.values as TypedArray, dtype);\n\n    const out = backend.makeTensorInfo(outShape, dtype);\n    const outData = backend.texData.get(out.dataId);\n    outData.values = outValues;\n    return out;\n  }\n\n  let program: BinaryOpProgram|BinaryOpPackedProgram;\n  if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n    program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);\n  } else {\n    program = new BinaryOpProgram(MUL, a.shape, b.shape);\n  }\n\n  return backend.runWebGLProgram(program, [a, b], dtype);\n}\n\nexport const multiplyConfig: KernelConfig = {\n  kernelName: Multiply,\n  backendName: 'webgl',\n  kernelFunc: multiply\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, NonMaxSuppressionV3, NonMaxSuppressionV3Attrs, NonMaxSuppressionV3Inputs, TypedArray} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport const nonMaxSuppressionV3Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV3,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend, attrs}) => {\n    backend_util.warn(\n        'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n\n    const {boxes, scores} = inputs as NonMaxSuppressionV3Inputs;\n    const {maxOutputSize, iouThreshold, scoreThreshold} =\n        attrs as unknown as NonMaxSuppressionV3Attrs;\n\n    const gpuBackend = backend as MathBackendWebGL;\n\n    const boxesVals = gpuBackend.readSync(boxes.dataId) as TypedArray;\n    const scoresVals = gpuBackend.readSync(scores.dataId) as TypedArray;\n\n    const maxOutputSizeVal = maxOutputSize;\n    const iouThresholdVal = iouThreshold;\n    const scoreThresholdVal = scoreThreshold;\n\n    return kernel_impls.nonMaxSuppressionV3Impl(\n        boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal,\n        scoreThresholdVal);\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, NonMaxSuppressionV4, NonMaxSuppressionV4Attrs, NonMaxSuppressionV4Inputs, TypedArray} from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV4Impl = kernel_impls.nonMaxSuppressionV4Impl;\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport const nonMaxSuppressionV4Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV4,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend, attrs}) => {\n    backend_util.warn(\n        'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n\n    const {boxes, scores} = inputs as NonMaxSuppressionV4Inputs;\n    const {maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize} =\n        attrs as unknown as NonMaxSuppressionV4Attrs;\n\n    const gpuBackend = backend as MathBackendWebGL;\n\n    const boxesVals = gpuBackend.readSync(boxes.dataId) as TypedArray;\n    const scoresVals = gpuBackend.readSync(scores.dataId) as TypedArray;\n\n    const {selectedIndices, validOutputs} = nonMaxSuppressionV4Impl(\n        boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold,\n        padToMaxOutputSize);\n\n    return [selectedIndices, validOutputs];\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, TypedArray} from '@tensorflow/tfjs-core';\nimport {NonMaxSuppressionV5, NonMaxSuppressionV5Attrs, NonMaxSuppressionV5Inputs} from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV5Impl = kernel_impls.nonMaxSuppressionV5Impl;\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport const nonMaxSuppressionV5Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV5,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend, attrs}) => {\n    backend_util.warn(\n        'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n\n    const {boxes, scores} = inputs as NonMaxSuppressionV5Inputs;\n    const {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma} =\n        attrs as unknown as NonMaxSuppressionV5Attrs;\n\n    const gpuBackend = backend as MathBackendWebGL;\n\n    const boxesVals = gpuBackend.readSync(boxes.dataId) as TypedArray;\n    const scoresVals = gpuBackend.readSync(scores.dataId) as TypedArray;\n\n    const maxOutputSizeVal = maxOutputSize;\n    const iouThresholdVal = iouThreshold;\n    const scoreThresholdVal = scoreThreshold;\n    const softNmsSigmaVal = softNmsSigma;\n\n    const {selectedIndices, selectedScores} = nonMaxSuppressionV5Impl(\n        boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal,\n        scoreThresholdVal, softNmsSigmaVal);\n\n    return [selectedIndices, selectedScores];\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class RotateProgram implements GPGPUProgram {\n  variableNames = ['Image'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      imageShape: [number, number, number, number], radians: number,\n      fillValue: number|[number, number, number],\n      center: number|[number, number]) {\n    const imageHeight = imageShape[1];\n    const imageWidth = imageShape[2];\n    const sinFactor = Math.sin(radians).toFixed(3);\n    const cosFactor = Math.cos(radians).toFixed(3);\n    this.outputShape = imageShape;\n\n    const [centerX, centerY] =\n        backend_util.getImageCenter(center, imageHeight, imageWidth);\n    const centerXString = centerX.toFixed(3);\n    const centerYString = centerY.toFixed(3);\n\n    let fillSnippet = '';\n    if (typeof fillValue === 'number') {\n      fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;\n    } else {\n      fillSnippet = `\n        vec3 fill = vec3(${fillValue.join(',')});\n        float outputValue = fill[coords[3]];`;\n    }\n\n    this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${centerXString}) * ${\n        cosFactor} - (float(y) - ${centerYString}) * ${sinFactor};\n          float coordYFloat = (float(x) - ${centerXString}) * ${\n        sinFactor} + (float(y) - ${centerYString}) * ${cosFactor};\n          int coordX = int(round(coordXFloat + ${centerXString}));\n          int coordY = int(round(coordYFloat + ${centerYString}));\n          ${fillSnippet}\n          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${\n        imageHeight}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tensor4D} from '@tensorflow/tfjs-core';\nimport {RotateWithOffset, RotateWithOffsetAttrs, RotateWithOffsetInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {RotateProgram} from '../rotate_gpu';\n\nexport const rotateWithOffsetConfig: KernelConfig = {\n  kernelName: RotateWithOffset,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {image} = inputs as RotateWithOffsetInputs;\n    const {radians, fillValue, center} = attrs as {} as RotateWithOffsetAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const program = new RotateProgram(\n        (image as Tensor4D).shape, radians, fillValue, center);\n    const output = webglBackend.runWebGLProgram(program, [image], image.dtype);\n    return output;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sin} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SIN = CHECK_NAN_SNIPPET_UNARY + `\n  return sin(x);\n`;\n\nexport const sin = unaryKernelFunc(SIN);\n\nexport const sinConfig: KernelConfig = {\n  kernelName: Sin,\n  backendName: 'webgl',\n  kernelFunc: sin,\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Square} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SQUARE = `return x * x;`;\n\nexport const square = unaryKernelFunc(SQUARE);\n\nexport const squareConfig: KernelConfig = {\n  kernelName: Square,\n  backendName: 'webgl',\n  kernelFunc: square,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, SquaredDifference} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\n\nexport const squaredDifference = binaryKernelFunc(\n    {opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE});\n\nexport const squaredDifferenceConfig: KernelConfig = {\n  kernelName: SquaredDifference,\n  backendName: 'webgl',\n  kernelFunc: squaredDifference,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sub} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {subImplCPU as cpuSub} from '../kernel_utils/shared';\n\nconst SUB = 'return a - b;';\n\nexport const subKernelFunc = binaryKernelFunc({\n  opSnippet: SUB,\n  packedOpSnippet: SUB,\n  supportsComplex: true,\n  cpuKernelImpl: cpuSub\n});\n\nexport const subConfig: KernelConfig = {\n  kernelName: Sub,\n  backendName: 'webgl',\n  kernelFunc: subKernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tan} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst TAN = `return tan(x);`;\n\nexport const tan = unaryKernelFunc(TAN);\n\nexport const tanConfig: KernelConfig = {\n  kernelName: Tan,\n  backendName: 'webgl',\n  kernelFunc: tan,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Unique, UniqueAttrs, UniqueInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {uniqueImplCPU} from '../kernel_utils/shared';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function unique(\n    args:\n        {inputs: UniqueInputs, attrs: UniqueAttrs, backend: MathBackendWebGL}):\n    TensorInfo[] {\n  const {inputs, attrs, backend} = args;\n  const {axis} = attrs;\n  const {x} = inputs;\n  assertNotComplex(x, 'unique');\n\n  // For now, always forward calculation to the CPU backend.\n  console.warn(\n      'WARNING: ',\n      'UI might be locked temporarily as data is being downloaded');\n  const values = backend.readSync(x.dataId);\n  const {outputValues, outputShape, indices} =\n      uniqueImplCPU(values, axis, x.shape, x.dtype);\n  return [\n    backend.makeTensorInfo(outputShape, x.dtype, outputValues),\n    backend.makeTensorInfo([indices.length], 'int32', indices),\n  ];\n}\n\nexport const uniqueConfig: KernelConfig = {\n  kernelName: Unique,\n  backendName: 'webgl',\n  kernelFunc: unique as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {KernelConfig, registerKernel} from '@tensorflow/tfjs-core';\n\nimport {addConfig} from './kernels/Add';\nimport {atan2Config} from './kernels/Atan2';\nimport {avgPoolConfig} from './kernels/AvgPool';\nimport {avgPoolBackpropConfig} from './kernels/AvgPoolBackprop';\nimport {batchNormConfig} from './kernels/BatchNorm';\nimport {castConfig} from './kernels/Cast';\nimport {complexConfig} from './kernels/Complex';\nimport {concatConfig} from './kernels/Concat';\nimport {cosConfig} from './kernels/Cos';\nimport {divConfig} from './kernels/Div';\nimport {fftConfig} from './kernels/FFT';\nimport {flipLeftRightConfig} from './kernels/FlipLeftRight';\nimport {fromPixelsConfig} from './kernels/FromPixels';\nimport {identityConfig} from './kernels/Identity';\nimport {ifftConfig} from './kernels/IFFT';\nimport {imagConfig} from './kernels/Imag';\nimport {maxConfig} from './kernels/Max';\nimport {maxPoolConfig} from './kernels/MaxPool';\nimport {maxPoolBackpropConfig} from './kernels/MaxPoolBackprop';\nimport {maxPoolWithArgmaxConfig} from './kernels/MaxPoolWithArgmax';\nimport {meanConfig} from './kernels/Mean';\nimport {mirrorPadConfig} from './kernels/MirrorPad';\nimport {multiplyConfig} from './kernels/Multiply';\nimport {nonMaxSuppressionV3Config} from './kernels/NonMaxSuppressionV3';\nimport {nonMaxSuppressionV4Config} from './kernels/NonMaxSuppressionV4';\nimport {nonMaxSuppressionV5Config} from './kernels/NonMaxSuppressionV5';\nimport {notEqualConfig} from './kernels/NotEqual';\nimport {realConfig} from './kernels/Real';\nimport {reshapeConfig} from './kernels/Reshape';\nimport {rotateWithOffsetConfig} from './kernels/RotateWithOffset';\nimport {sinConfig} from './kernels/Sin';\nimport {squareConfig} from './kernels/Square';\nimport {squaredDifferenceConfig} from './kernels/SquaredDifference';\nimport {subConfig} from './kernels/Sub';\nimport {tanConfig} from './kernels/Tan';\nimport {transposeConfig} from './kernels/Transpose';\nimport {uniqueConfig} from './kernels/Unique';\n\n// List all kernel configs here\nconst kernelConfigs: KernelConfig[] = [\n  addConfig,\n  atan2Config,\n  avgPoolConfig,\n  avgPoolBackpropConfig,\n  batchNormConfig,\n  castConfig,\n  complexConfig,\n  concatConfig,\n  cosConfig,\n  divConfig,\n  fftConfig,\n  flipLeftRightConfig,\n  fromPixelsConfig,\n  identityConfig,\n  ifftConfig,\n  imagConfig,\n  maxConfig,\n  maxPoolConfig,\n  maxPoolBackpropConfig,\n  maxPoolWithArgmaxConfig,\n  meanConfig,\n  mirrorPadConfig,\n  multiplyConfig,\n  nonMaxSuppressionV3Config,\n  nonMaxSuppressionV4Config,\n  nonMaxSuppressionV5Config,\n  notEqualConfig,\n  realConfig,\n  reshapeConfig,\n  rotateWithOffsetConfig,\n  sinConfig,\n  squareConfig,\n  subConfig,\n  squaredDifferenceConfig,\n  tanConfig,\n  transposeConfig,\n  uniqueConfig,\n];\n\nfor (const kernelConfig of kernelConfigs) {\n  registerKernel(kernelConfig);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, TensorInfo, Transpose, TransposeAttrs, TransposeInputs, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {transposeImpl} from './Transpose_impl';\nimport {transposeImplCPU as cpuTranspose} from './Transpose_impl';\n\nexport const transposeConfig: KernelConfig = {\n  kernelName: Transpose,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as TransposeInputs;\n    const {perm} = attrs as {} as TransposeAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const xRank = x.shape.length;\n\n    const newShape: number[] = new Array(xRank);\n    for (let i = 0; i < newShape.length; i++) {\n      newShape[i] = x.shape[perm[i]];\n    }\n\n    let out: TensorInfo;\n    if (webglBackend.shouldExecuteOnCPU([x])) {\n      const xTexData = webglBackend.texData.get(x.dataId);\n      const values = xTexData.values as TypedArray;\n      const outValues = cpuTranspose(values, x.shape, x.dtype, perm, newShape);\n\n      out = webglBackend.makeTensorInfo(newShape, x.dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n    } else {\n      out = transposeImpl(x, perm, webglBackend);\n    }\n    return out;\n  }\n};\n","/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '2.7.0';\nexport {version};\n"],"names":["contexts","WEBGL_ATTRIBUTES","alpha","antialias","premultipliedAlpha","preserveDrawingBuffer","depth","stencil","failIfMajorPerformanceCaveat","setWebGLContext","webGLVersion","gl","getWebGLContext","newCtx","Error","canvas","OffscreenCanvas","document","createElement","createCanvas","addEventListener","ev","preventDefault","getContext","getWebGLRenderingContext","console","log","isContextLost","disable","DEPTH_TEST","STENCIL_TEST","BLEND","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","enable","SCISSOR_TEST","CULL_FACE","cullFace","BACK","PackingScheme","TextureUsage","PhysicalTextureType","getUnpackedMatrixTextureShapeWidthHeight","rows","columns","getDenseTexShape","shape","size","util","sizeFromShape","texelsNeeded","Math","ceil","sizeToSquarishShape","getPackedMatrixTextureShapeWidthHeight","max","getTextureConfig","textureHalfFloatExtension","glany","internalFormatFloat","internalFormatHalfFloat","internalFormatPackedHalfFloat","internalFormatPackedFloat","textureFormatFloat","downloadTextureFormat","downloadUnpackNumChannels","defaultNumChannels","textureTypeHalfFloat","textureTypeFloat","env","getNumber","R32F","R16F","RGBA16F","RGBA32F","RED","HALF_FLOAT","FLOAT","RGBA","HALF_FLOAT_OES","callAndCheck","func","returnValue","getBool","error","getError","NO_ERROR","getWebGLErrorMessage","checkWebGLError","canBeRepresented","num","abs","status","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","getExtensionOrThrow","extensionName","throwIfNull","getExtension","createVertexShader","vertexShaderSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","createFragmentShader","fragmentShaderSource","fragmentShader","FRAGMENT_SHADER","shaderInfoLog","lineNumberRegexResult","lineNumberRegex","exec","lineNumber","shaderLines","split","pad","length","toString","linesWithLineNumbers","map","line","rightPad","maxLineLength","i","beforeErrorLines","slice","errorLine","afterErrorLines","join","logShaderSourceAndInfoLog","createProgram","linkProgram","program","getProgramParameter","LINK_STATUS","getProgramInfoLog","validateProgram","VALIDATE_STATUS","createStaticVertexBuffer","data","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","createStaticIndexBuffer","ELEMENT_ARRAY_BUFFER","createTexture","validateTextureSize","width","height","maxTextureSize","createFramebuffer","bindVertexBufferToProgramAttribute","attribute","arrayEntriesPerItem","itemStrideInBytes","itemOffsetInBytes","loc","getAttribLocation","vertexAttribPointer","enableVertexAttribArray","bindTextureUnit","texture","textureUnit","validateTextureUnit","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","getProgramUniformLocationOrThrow","uniformName","getUniformLocation","getProgramUniformLocation","bindTextureToProgramUniformSampler","uniformSamplerLocation","uniform1i","bindColorTextureToFramebuffer","framebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","unbindColorTextureFromFramebuffer","validateFramebuffer","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","getFramebufferErrorMessage","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","returnTOrNull","failureMessage","tOrNull","maxTextureUnit","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glTextureUnit","getBatchDim","dimsToSkip","getRowsCols","getShapeAs3D","shapeAs3D","getTextureShapeFromLogicalShape","logShape","isPacked","maxTexSize","d","nearestLargerEven","squeezeResult","squeezeShape","newShape","batchDim","cols","isEven","n","isReshapeFree","shape1","shape2","arraysEqual","shape1Cols","shape2Cols","MAX_TEXTURE_SIZE","MAX_TEXTURES_IN_SHADER","getWebGLMaxTextureSize","getParameter","getMaxTexturesInShader","MAX_TEXTURE_IMAGE_UNITS","min","getWebGLDisjointQueryTimerVersion","queryTimerVersion","hasExtension","isWebGLVersionEnabled","e","isCapableOfRenderingToFloatTexture","createFloatTextureAndBindToFramebuffer","isDownloadFloatTextureEnabled","COLOR_BUFFER_HALF_FLOAT","texConfig","texImage2D","frameBuffer","isFrameBufferComplete","deleteTexture","deleteFramebuffer","createHalfFloatTextureAndBindToFramebuffer","isWebGLFenceEnabled","fenceSync","assertNotComplex","tensor","opName","Array","isArray","forEach","t","assert","dtype","viewport","scissor","ENV","createSimpleBinaryKernelImpl","op","aShape","bShape","aVals","bVals","backend_util","assertAndGetBroadcastShape","resultRank","resultStrides","computeStrides","resultSize","result","getTypedArrayFromDType","aRank","bRank","aStrides","bStrides","aBroadcastDims","getBroadcastDims","bBroadcastDims","indexToLoc","aLoc","aIndex","locToIndex","bLoc","bIndex","registerFlag","get","device_util","isMobile","threshold","addImpl","a","b","createSimpleUnaryImpl","values","attrs","newValues","ceilImpl","xi","expImpl","exp","expm1Impl","expm1","floorImpl","floor","logImpl","multiplyImpl","aValue","bValue","notEqualImpl","rsqrtImpl","sqrt","squaredDifferenceImpl","diff","subImpl","vals","resultValues","Float32Array","reduceSize","outShape","offset","j","value","begin","isContinous","slice_util","isSliceContinous","xStrides","flatOffset","computeFlatOffset","subarray","outVals","rank","strides","xLoc","idx","xIndex","xVals","xShape","perm","xRank","xSize","newStrides","newLoc","axis","$axis","parseAxisParam","uniqueElements","indices","Int32Array","inputBuffer","TensorBuffer","uniqueIndices","is1DTensor","element","axisValues","m","push","undefined","uniqueIndex","Object","keys","outputTmpShape","outputBuffer","uniqueElementIndex","set","outputShape","outputValues","simpleAbsImpl","simpleAbsImplCPU","addImplCPU","ceilImplCPU","expImplCPU","expm1ImplCPU","floorImplCPU","logImplCPU","maxImpl","maxImplCPU","multiplyImplCPU","rsqrtImplCPU","sliceImpl","sliceImplCPU","subImplCPU","transposeImpl","transposeImplCPU","uniqueImpl","uniqueImplCPU","shared","AddNProgram","[object Object]","shapes","this","variableNames","_","snippets","variable","operation","userCode","AddNPackedProgram","ArgMinMaxProgram","reduceInfo","firstPass","windowSize","batchSize","outSize","compOp","indexSnippet","getVecChannels","name","getChannels","getGlslDifferences","version","varyingVs","varyingFs","texture2D","output","defineOutput","defineSpecialNaN","defineSpecialInf","defineRound","getLogicalCoordinatesFromFlatIndex","coords","index","stride","getFlatIndexFrom3D","ENCODE_FLOAT_SNIPPET","makeShader","inputsInfo","usesPackedTextures","prefixSnippets","x","shapeInfo","logicalShape","isUniform","inputPrefixSnippet","inputSamplingSnippet","inInfo","outShapeInfo","res","getPackedSamplerFromInInfo","getSamplerFromInInfo","inShape","inputInfo","texName","texFuncSnippet","charAt","toUpperCase","funcName","inRank","outRank","broadcastDims","type","getCoordsDataType","rankDiff","coordsSnippet","fields","unpackedCoordsSnippet","s","isInputScalar","isOutputScalar","indexOf","getPackedSamplerAtOutputCoords","outTexShape","texShape","inTexShape","getSamplerAtOutputCoords","getInputSamplingSnippet","glsl","floatTextureSampleSnippet","getFloatTextureSampleSnippet","outputSamplingSnippet","floatTextureSetOutputSnippet","shaderPrefix","SAMPLE_1D_SNIPPET","SAMPLE_2D_SNIPPET","SAMPLE_3D_SNIPPET","getShaderPrefix","getOutputScalarCoords","packedTexShape","getOutputPacked1DCoords","texelsInLogicalRow","getOutputPacked2DCoords","texelsInBatch","getOutputPacked3DCoords","texelsInBatchN","batches","getOutputPackedNDCoords","getPackedOutputSamplingSnippet","getFloatTextureSetRGBASnippet","getOutput1DCoords","getOutput2DCoords","coordsFromIndexSnippet","shader_util.getLogicalCoordinatesFromFlatIndex","getOutput3DCoords","getOutput4DCoords","getOutput5DCoords","getOutput6DCoords","getOutputSamplingSnippet","getFloatTextureSetRSnippet","SHADER_PACKED_PREFIX","texNumR","texNumC","tNumR","tNumC","getFlatOffsetUniformName","getSamplerScalar","getUniformSampler","getSampler1D","keptDims","squeezedShape","newInputInfo","squeezeInputInfo","params","getSqueezedParams","getSampler2D","stride0","stride1","getSampler3D","stride2","getSampler4D","stride3","getSampler5D","stride4","getSampler6D","getPackedSamplerScalar","getPackedSampler1D","valuesPerRow","getPackedSampler2D","getPackedSampler3D","getPackedSamplerND","inSize","JSON","parse","stringify","ArgMinMaxPackedProgram","sourceLocSetup","sourceRank","sourceLocDType","channels","inChannel","intChannels","srcRCoords","concat","srcGCoords","srcBCoords","srcACoords","fetchCandidateIdx","fetchValue","getBestIndicesAChannelSnippet","AvgPool2DBackpropProgram","convInfo","filterHeight","filterWidth","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","left","avgMultiplier","outHeight","outWidth","AvgPool3DBackpropProgram","filterDepth","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","outDepth","PRELU","BinaryOpProgram","BinaryOpPackedProgram","checkOutOfBounds","checkOutOfBoundsString","ClipProgram","gpgpu","webGLProgram","minLoc","getUniformLocationNoThrow","maxLoc","uniform1f","ClipPackedProgram","ComplexAbsProgram","Conv2DDerFilterProgram","filterShape","isChannelsLast","dataFormat","inHeight","inWidth","Conv2DDerInputProgram","rowDim","colDim","channelDim","outChannels","Conv3DDerFilterProgram","inDepth","Conv3DDerInputProgram","DepthwiseConv2DDerFilterProgram","channelMul","inChannels","DepthwiseConv2DDerInputProgram","Conv2DProgram","addBias","activation","hasPreluActivationWeights","inputDepthNearestVec4","inputDepthVec4Remainder","activationSnippet","applyActivationSnippet","addBiasSnippet","Conv3DProgram","DepthwiseConv2DProgram","hasPreluActivation","xNumRows","xNumCols","DepthwiseConvPacked2DProgram","texelsAcross","mainLoop","r","c","texelC","nextTexelOffset","CropAndResizeProgram","imageShape","boxShape","cropSize","method","extrapolationValue","batch","imageHeight","imageWidth","numBoxes","cropHeight","cropWidth","methodId","inputHeightFloat","inputWidthFloat","heightRatio","heightScale","inY","widthRatio","widthScale","inX","CumSumProgram","exclusive","reverse","val","getCoords","condition","idxString","getFinalCoord","DecodeMatrixProgram","DENSE","DecodeMatrixPackedProgram","DepthToSpaceProgram","blockSize","getHeightCoordString","getWidthCoordString","getDepthCoordString","getOutputDepthSize","getInputSamplingString","DiagProgram","EncodeFloatProgram","DOWNLOAD","EncodeFloatPackedProgram","EncodeMatrixProgram","inputIsUnsignedByte","shader_util.getFlatIndexFrom3D","EncodeMatrixPackedProgram","row","col","channel","FillProgram","valueLoc","GatherProgram","indicesLength","sourceCoords","currentCoords","getSourceCoords","GatherNDProgram","sliceDim","stridesType","strideString","webgl_util.createVertexShader","createVertexBuffer","webgl_util.createStaticVertexBuffer","createIndexBuffer","webgl_util.createStaticIndexBuffer","Uint16Array","createAndConfigureTexture","internalFormat","textureFormat","textureType","webgl_util.validateTextureSize","webgl_util.createTexture","tex2d","webgl_util.callAndCheck","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","getInternalFormatForFloat32MatrixTexture","textureConfig","createFloat32MatrixTexture","tex_util.getUnpackedMatrixTextureShapeWidthHeight","getInternalFormatForFloat16MatrixTexture","createFloat16MatrixTexture","getInternalFormatForUnsignedBytesMatrixTexture","createUnsignedBytesMatrixTexture","UNSIGNED_BYTE","getInternalFormatForPackedMatrixTexture","createPackedMatrixTexture","tex_util.getPackedMatrixTextureShapeWidthHeight","getInternalFormatForFloat16PackedMatrixTexture","createFloat16PackedMatrixTexture","bindVertexProgramAttributeStreams","vertexBuffer","webgl_util.bindVertexBufferToProgramAttribute","uploadDenseMatrixToTexture","dataForUpload","texelDataType","Uint8Array","uploadPixelDataToTexture","pixels","createBufferFromOutputTexture","gl2","PIXEL_PACK_BUFFER","bufferSizeBytes","bytesPerFloat","STREAM_READ","readPixels","downloadFloat32MatrixFromBuffer","downloadTarget","getBufferSubData","downloadByteEncodedFloatMatrixFromOutputTexture","w","h","downloadPackedMatrixFromBuffer","physicalRows","physicalCols","tex_util.getPackedRGBAArraySizeFromMatrixShape","downloadMatrixFromPackedOutputTexture","packedRGBA","GPGPUContext","glVersion","COLOR_BUFFER_FLOAT","TEXTURE_FLOAT","TEXTURE_HALF_FLOAT","textureFloatExtension","webgl_util.getExtensionOrThrow","webgl_util.hasExtension","colorBufferFloatExtension","colorBufferHalfFloatExtension","gpgpu_util.createVertexBuffer","indexBuffer","gpgpu_util.createIndexBuffer","webgl_util.createFramebuffer","tex_util.getTextureConfig","debug","disposed","warn","outputTexture","finish","deleteBuffer","throwIfDisposed","gpgpu_util.createFloat32MatrixTexture","gpgpu_util.createFloat16MatrixTexture","gpgpu_util.createUnsignedBytesMatrixTexture","gpgpu_util.uploadPixelDataToTexture","gpgpu_util.uploadDenseMatrixToTexture","gpgpu_util.createFloat16PackedMatrixTexture","gpgpu_util.createPackedMatrixTexture","webgl_util.unbindColorTextureFromFramebuffer","downloadMatrixDriver","gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture","gpgpu_util.downloadPackedMatrixFromBuffer","gpgpu_util.downloadFloat32MatrixFromBuffer","bindTextureToFrameBuffer","gpgpu_util.createBufferFromOutputTexture","unbindTextureToFrameBuffer","fenceContext","createFence","pollFence","query","isFencePassed","sync","SYNC_GPU_COMMANDS_COMPLETE","flush","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","beginQuery","endQuery","isQueryAvailable","gpgpu_util.downloadMatrixFromPackedOutputTexture","webgl_util.createFragmentShader","gpgpu_util.createVertexShader","webgl_util.createProgram","attachShader","webgl_util.linkProgram","webgl_util.validateProgram","vertexAttrsAreBound","setProgram","gpgpu_util.bindVertexProgramAttributeStreams","deleteProgram","useProgram","shouldThrow","webgl_util.getProgramUniformLocationOrThrow","webgl_util.getProgramUniformLocation","inputMatrixTexture","uniformLocation","throwIfNoProgram","webgl_util.bindTextureToProgramUniformSampler","outputMatrixTexture","setOutputMatrixTextureDriver","outputPackedMatrixTexture","startRow","numRows","startColumn","numColumns","setOutputMatrixWriteRegionDriver","webgl_util.validateFramebuffer","debugValidate","drawElements","TRIANGLES","UNSIGNED_SHORT","disjointQueryTimerExtension","getQueryTimerExtension","ext","getQueryTimerExtensionWebGL2","createQuery","TIME_ELAPSED_EXT","getQueryTimerExtensionWebGL1","createQueryEXT","beginQueryEXT","endQueryEXT","repeatedTry","getQueryTime","getQueryParameter","QUERY_RESULT","getQueryObjectEXT","QUERY_RESULT_EXT","available","QUERY_RESULT_AVAILABLE","disjoint","GPU_DISJOINT_EXT","QUERY_RESULT_AVAILABLE_EXT","Promise","resolve","addItemToPoll","arr","linearSearchLastTrue","itemsToPoll","isDoneFn","resolveFn","pollItems","webgl_util.bindColorTextureToFramebuffer","downloadAndDecode","outputMatrixTextureMaybePacked","y","validateBinaryAndProgram","shapeInfos","inputs","shapeA","input","shapeB","texShapeA","texShapeB","texData","Im2ColPackedProgram","inputShape","itemsPerBlockRow","unrolled","LRNProgram","radius","bias","beta","rad","maxD","powOperator","basis","LRNGradProgram","depthRadius","LRNPackedProgram","MaxPool2DBackpropProgram","lastIndex","MaxPool3DBackpropProgram","MatMulPackedProgram","transposeA","transposeB","sharedDim","sharedDimensionPacked","aSample","bSample","aSwizzle","bSwizzle","batchASnippet","batchBSnippet","MultinomialProgram","numOutcomes","numSamples","seed","seedLoc","OneHotProgram","numIndices","onValue","offValue","PackProgram","outOfBoundsCondition","dims","cond","getOutOfBoundsCondition","setup","innerDims","getSetup","coord","getSourceCoordsArr","getOutput","PadProgram","paddings","constantValue","p","start","end","unpackedCoords","PadPackedProgram","source","cLimit","componentSetup","paddingArea","Pool2DProgram","poolType","computePositions","flattenPositions","includeBatchInIndex","isAvgPool","batchFlattenPositionStr","flattenPositionStr","initializationValue","compareOp","filterWidthNearestVec4","filterWidthVec4Remainder","updateSnippet","Pool3DProgram","ReduceProgram","reduceType","windowSizeNearestVec4","windowSizeVec4Remainder","vecType","ReshapePackedProgram","thisRC","ResizeBilinearBackpropProgram","dy","alignCorners","xHeight","xWidth","yHeight","yWidth","effectiveXSize","effectiveYSize","invHeightScale","invWidthScale","winHeight","winWidth","ResizeBilinearProgram","newHeight","newWidth","oldHeight","oldWidth","effectiveInSize","effectiveOutSize","ResizeBilinearPackedProgram","ResizeNearestNeigborBackpropProgram","ResizeNearestNeighborProgram","roundBase","ReverseProgram","inCoords","getInCoord","ReversePackedProgram","nextColumn","nextRow","getChannel","inCoordsArray","channels1","getR","getG","getB","getA","ScatterProgram","updateSize","indicesRank","updatesRank","summingDupeIndex","indicesString","indicesSnippet","updatesString","updatesSnippet","SegmentOpProgram","segOpInfo","segOpType","numSegments","checkValueOutOfBounds","checkSegmentIdOutOfBounds","SelectProgram","cRank","cCoords","abCoords","cCoordVars","abCoordVars","SliceProgram","destSize","uniformPart","body","startLoc","uniform1iv","SlicePackedProgram","sourceLoc","upperRow","lowerRow","StridedSliceProgram","inputDtype","newCoords","outputAxis","TextureManager","shapeRC","usage","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","freeTextures","usedTextures","texBytes","computeBytes","numFreeTextures","numUsedTextures","_numBytesFree","newTexture","shift","PACKED_2X2_FLOAT32","PACKED_2X2_FLOAT16","UNPACKED_FLOAT32","UNPACKED_FLOAT16","PACKED_4X1_UNSIGNED_BYTE","_numBytesAllocated","logicalTexType","deleteTexThreshold","deleteMatrixTexture","texList","texIndex","splice","logEnabled","total","freeRatio","round","numBytesAllocated","numBytesFree","tex","internalFormatForPhysicalTexType","numElements","packedWidth","packedHeight","numBytesForInternalFormat","UPLOAD","RENDER","getPhysicalTextureForRendering","PIXELS","shapeRowsCol","TileProgram","reps","UnaryOpProgram","opSnippet","CHECK_NAN_SNIPPET","ABS","RELU","RELU6","ELU","SELU","SELU_SCALEALPHA","SELU_SCALE","NEG","CEIL","FLOOR","EXP","EXPM1","ERF","ERF_P","ERF_A1","ERF_A2","ERF_A3","ERF_A4","ERF_A5","CLONE","UnaryOpPackedProgram","UnpackProgram","segment_util","kernel_impls","tile","topkImpl","whereImpl","binaryCaches","mapActivationToShaderProgram","packed","unary_packed_op.RELU","unary_op.RELU","unary_packed_op.ELU","unary_op.ELU","unary_packed_op.RELU6","unary_op.RELU6","binaryop_packed_gpu.PRELU","binaryop_gpu.PRELU","MathBackendWebGL","KernelBackend","super","WeakMap","WeakSet","binaryCache","gpgpuCreatedLocally","textureManager","numMBBeforeWarning","global","screen","window","devicePixelRatio","DataStorage","engine","numDataIds","cpuBackend","pendingDeletes","checkNumericalProblems","dataId","refCount","complexParentRefCount","has","tensorInfo","textureData","disposeData","complexTensorInfos","unary_op.CLONE","runWebGLProgram","readSync","disposeIntermediateTensorInfo","convertAndCacheOnCPU","shouldTimeProgram","activeTimers","now","realValues","real","imagValues","imag","mergeRealAndImagArrays","getValuesFromTexture","downloadWaitMs","pendingRead","subscribers","read","tmpDownloadTarget","decode","tmpData","createBufferFromTexture","tex_util.getDenseTexShape","createAndWaitForFence","ps","all","dTypeVals","delete","pendingDisposal","webgl_util.canBeRepresented","tmpTarget","downloadMatrixFromPackedTexture","shouldUsePackedProgram","webgl_util.getShapeAs3D","f","oldActiveTimers","newActiveTimers","outerMostTime","programTimersStack","flattenedActiveTimerQueries","flatten","filter","flattenedActiveTimerNames","uploadWaitMs","kernelMs","wallMs","sum","ms","unreliable","numBytesInGPU","numBytesInGPUAllocated","numBytesInGPUFree","startMs","endMs","waitForQueryAndGetTime","timerQuery","add","releaseGPUData","key","origDataId","dataRefCount","releaseTexture","uploadToGPU","findBackend","sizeThreshold","getCPUBackend","warnedAboutCPUBackend","every","shouldExecuteOnCPU","outValues","makeOutput","customSetup","getCustomSetupFunc","compileAndRun","shallowSlice","xTexData","newTexData","assign","cpuRes","tryRunOnCpuOrThrow","stridedSlice","computeOutShape","some","neg","packedUnaryOp","unary_op.NEG","outerShapeA","outerShapeB","transpose","a3D","as3D","b3D","tf.mul","upcastType","preluActivationWeights","hasBias","fusedActivation","inputImage","outputImage","decodedData","decodeString","buf","gather","blockShape","crops","prod","reduce","reshaped","getReshaped","permuted","getPermuted","reshapedPermuted","getReshapedPermuted","sliceBeginCoords","getSliceBeginCoords","sliceSize","getSliceSize","reshape","completePaddings","paddedX","reshapedPaddedShape","permutedReshapedPaddedPermutation","flattenShape","paddedXT","computeOptimalWindowSize","bestIndicesA","argReduce","argReducePacked","axes","assertAxesAreInnerMostDims","reduceShape","computeOutAndReduceShapes","a2D","as2D","outputDType","tf.sumOutType","segmentIds","permutation","getAxesPermutation","permutedX","getInnerMostAxes","segOpCompute","getUndoAxesPermutation","segOpComputeOptimalWindowSize","range","argMinMaxReduce","log2","prevResult","dispose","packedBinaryOp","less","greater","condVals","dataSync","k","sorted","minimum","maximum","complexTensor","complexPart","tensors","midIndex","leftSide","addN","rightSide","d1","d2","unary_op.CEIL","unary_op.FLOOR","unary_op.EXP","unary_op.EXPM1","logits","dim","maxLogit","expandedShape","expandShapeToKeepDim","tf.sub","sumExp","div","unary_op.SELU","unary_op.ABS","xData","makeComplexComponentTensorInfo","unary_op.ERF","unary_op.STEP","sharedMatMulDim","outerShapeX","outerShapeFilter","batchMatMulWillBeUnpacked","reshapeWillBeExpensive","targetShape","xReshaped","filterReshaped","fusedBatchMatMul","originalXTexDataShape","webgl_util.isReshapeFree","pointwiseConv","pointwiseConvTexData","makeTensorFromDataId","numCols","x2ColShape","xSqueezed","squeeze","w2Row","im2ColProgram","im2Col","matmulProgram","product","conv2dByMatMul","conv2dWithIm2Row","shouldPackDepthwiseConv","outIndex","fill","avgPool3dBackpropProgram","maxPool3dPositionsProgram","maxPool3dPositions","maxPool3dBackPropProgram","normalized","probs","softmax","image","boxes","boxIndex","inputHeight","inputWidth","inputDepth","outputHeight","outputWidth","outputDepth","sizeSplits","updates","sliceRank","numUpdates","outputSize","calculateShapes","flattenIndices","flattenX","reshapeTensor","defaultValue","scalar","sparseIndices","sparseValues","indicesShape","resultShape","numSlices","prepareAndValidate","inferDtype","getArrayFromDType","makeTensor","stop","linspaceImpl","write","makeTensorInfo","afterShape","input3DShape","webgl_util.getBatchDim","webgl_util.getRowsCols","input3D","afterShapeAs3D","outputDtype","preventEagerUnpackingOfOutput","outData","packedOutput","outPackingScheme","tex_util.PackingScheme","texelShape","outTexUsage","dataToDispose","inputsData","packedInputs","uniformValues","unpackTensor","packTensor","savedInput","packedReshape","outputData","keyInputs","hasOffset","keyUserCode","constructor","gpgpu_math.makeShaderKey","binary","getAndSaveBinary","inputInfos","inShapeInfos","shader_compiler.makeShader","infLoc","nanLoc","uniformLocations","varName","gpgpu_math.compileProgram","startTimer","outTex","setOutputPackedMatrixTexture","setOutputMatrixTexture","Infinity","NaN","varLoc","varOffsetLoc","uniform1fv","setInputMatrixTexture","executeProgram","gpgpu_math.runProgram","info","endTimer","unpacked","outInfo","getBinary","HTMLCanvasElement","remove","floatPrecisionValue","tidy","debugFlag","underflowCheckValue","floatPrecision","webgl_util.getTextureShapeFromLogicalShape","isByteArray","tempDenseInputHandle","getTexture","preventEagerUnpacking","encodedOutputTarget","outputTexData","acquireTexture","float32Values","float32ToTypedArray","texType","warnedAboutMemory","mb","toFixed","bytesPerElement","fn","forceHalfFloat","isBrowser","registerBackend","webgl","identity","args","backend","incRef","identityConfig","kernelName","Identity","backendName","kernelFunc","complex","complexInfo","realTensorInfo","imagTensorInfo","complexConfig","Complex","unaryKernelFunc","webglBackend","binaryKernelFunc","packedOpSnippet","supportsComplex","cpuKernelImpl","aData","bData","complexParts","aPart","bPart","aHandle","bHandle","complexOutput","$dtype","out","ADD","addKernelFunc","cpuAdd","addConfig","Add","atan2","CHECK_NAN_SNIPPET_BINARY","atan2Config","Atan2","avgPoolConfig","AvgPool","filterSize","dimRoundingMode","eitherStridesOrDilationsAreOne","computePool2DInfo","avgPoolProgram","avgPoolBackpropConfig","AvgPoolBackprop","avgPoolBackpropProgram","BatchNormProgram","meanShape","varianceShape","offsetShape","scaleShape","varianceEpsilon","offsetSnippet","scaleSnippet","BatchNormPackedProgram","batchNormConfig","FusedBatchNorm","mean","variance","scale","finalInputs","notEqual","notEqualConfig","NotEqual","realConfig","Real","castConfig","Cast","cast","zerosTensor","tf.zeros","floatX","realPart","hasEncodingLoss","int","zerosTensorInfo","ConcatProgram","offsets","lastShift","ConcatPackedProgram","lastChannels","allChannels","getValueSnippet","shiftedChannels","channelIdx","imagConfig","Imag","$shape","inferFromImplicitShape","$xSize","reshapeConfig","Reshape","concatConfig","Concat","$inputs","assertParamsConsistent","concatImpl","reals","imags","realConcated","imagConcated","tensors2D","reshapedResult","cos","CHECK_NAN_SNIPPET_UNARY","cosConfig","Cos","divConfig","Div","FFTProgram","component","inverse","innerDim","exponentMultiplierSnippet","PI","resultDenominator","opString","fftImpl","inputSize","innerDimensionSize","realProgram","imagProgram","imagPart","complexOutputReshaped","fftConfig","FFT","FlipLeftRightProgram","flipLeftRightConfig","FlipLeftRight","FromPixelsProgram","FromPixelsPackedProgram","fromPixelsConfig","FromPixels","numChannels","isVideo","HTMLVideoElement","isImage","HTMLImageElement","videoWidth","videoHeight","fromPixels2DContext","drawImage","tempPixelHandle","ifftConfig","IFFT","MeanProgram","divisor","denominator","isInt","toPrecision","reductionType","reductionStages","stages","getReductionStages","previousResult","TransposeProgram","newDim","switched","originalOrder","switchedCoords","getSwitchedCoords","TransposePackedProgram","outputOrder","switchedOrder","getc","maxConfig","Max","reductionIndices","keepDims","origAxes","permutedAxes","maxInputIsTransposed","maxInput","maxInputValues","maxOutShape","reshapedInput","reduced","reshapedOutput","maxPoolConfig","MaxPool","maxPoolProgram","maxPoolBackpropConfig","MaxPoolBackprop","maxPoolPositionsProgram","maxPoolPositions","maxPoolBackPropProgram","maxPoolWithArgmaxConfig","MaxPoolWithArgmax","dilations","indexes","poolOutput","maxPoolWithArgmaxImpl","meanConfig","Mean","meanInputIsTransposed","intermediates","meanInput","meanInputValues","meanOutShape","meanImpl","MirrorPadProgram","mode","MirrorPadPackedProgram","padSetup","mirrorPadConfig","MirrorPad","COMPLEX_MULTIPLY","BinaryOpComplexProgram","MUL","multiplyConfig","Multiply","binaryop_complex_gpu.COMPLEX_MULTIPLY","cpuMultiply","nonMaxSuppressionV3Config","NonMaxSuppressionV3","scores","maxOutputSize","iouThreshold","scoreThreshold","gpuBackend","boxesVals","scoresVals","maxOutputSizeVal","iouThresholdVal","scoreThresholdVal","nonMaxSuppressionV3Impl","nonMaxSuppressionV4Impl","nonMaxSuppressionV4Config","NonMaxSuppressionV4","padToMaxOutputSize","selectedIndices","validOutputs","nonMaxSuppressionV5Impl","nonMaxSuppressionV5Config","NonMaxSuppressionV5","softNmsSigma","softNmsSigmaVal","selectedScores","RotateProgram","radians","fillValue","center","sinFactor","sin","cosFactor","centerX","centerY","getImageCenter","centerXString","centerYString","fillSnippet","rotateWithOffsetConfig","RotateWithOffset","sinConfig","Sin","square","squareConfig","Square","squaredDifference","squaredDifferenceConfig","SquaredDifference","SUB","subKernelFunc","cpuSub","subConfig","Sub","tan","kernelConfigs","Tan","Transpose","cpuTranspose","Unique","kernelConfig","registerKernel"],"mappings":"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"}